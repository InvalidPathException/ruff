// This is a generated file. Don't modify it by hand!
// Run `crates/ruff_python_ast/generate.py` to re-generate the file.

#[ruff_index::newtype_index]
pub struct ModModuleId;

impl ruff_text_size::Ranged for crate::ModModule {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ModExpressionId;

impl ruff_text_size::Ranged for crate::ModExpression {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtFunctionDefId;

impl ruff_text_size::Ranged for crate::StmtFunctionDef {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtClassDefId;

impl ruff_text_size::Ranged for crate::StmtClassDef {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtReturnId;

impl ruff_text_size::Ranged for crate::StmtReturn {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtDeleteId;

impl ruff_text_size::Ranged for crate::StmtDelete {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtTypeAliasId;

impl ruff_text_size::Ranged for crate::StmtTypeAlias {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtAssignId;

impl ruff_text_size::Ranged for crate::StmtAssign {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtAugAssignId;

impl ruff_text_size::Ranged for crate::StmtAugAssign {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtAnnAssignId;

impl ruff_text_size::Ranged for crate::StmtAnnAssign {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtForId;

impl ruff_text_size::Ranged for crate::StmtFor {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtWhileId;

impl ruff_text_size::Ranged for crate::StmtWhile {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtIfId;

impl ruff_text_size::Ranged for crate::StmtIf {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtWithId;

impl ruff_text_size::Ranged for crate::StmtWith {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtMatchId;

impl ruff_text_size::Ranged for crate::StmtMatch {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtRaiseId;

impl ruff_text_size::Ranged for crate::StmtRaise {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtTryId;

impl ruff_text_size::Ranged for crate::StmtTry {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtAssertId;

impl ruff_text_size::Ranged for crate::StmtAssert {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtImportId;

impl ruff_text_size::Ranged for crate::StmtImport {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtImportFromId;

impl ruff_text_size::Ranged for crate::StmtImportFrom {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtGlobalId;

impl ruff_text_size::Ranged for crate::StmtGlobal {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtNonlocalId;

impl ruff_text_size::Ranged for crate::StmtNonlocal {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtExprId;

impl ruff_text_size::Ranged for crate::StmtExpr {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtPassId;

impl ruff_text_size::Ranged for crate::StmtPass {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtBreakId;

impl ruff_text_size::Ranged for crate::StmtBreak {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtContinueId;

impl ruff_text_size::Ranged for crate::StmtContinue {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StmtIpyEscapeCommandId;

impl ruff_text_size::Ranged for crate::StmtIpyEscapeCommand {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprBoolOpId;

impl ruff_text_size::Ranged for crate::ExprBoolOp {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprNamedId;

impl ruff_text_size::Ranged for crate::ExprNamed {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprBinOpId;

impl ruff_text_size::Ranged for crate::ExprBinOp {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprUnaryOpId;

impl ruff_text_size::Ranged for crate::ExprUnaryOp {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprLambdaId;

impl ruff_text_size::Ranged for crate::ExprLambda {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprIfId;

impl ruff_text_size::Ranged for crate::ExprIf {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprDictId;

impl ruff_text_size::Ranged for crate::ExprDict {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprSetId;

impl ruff_text_size::Ranged for crate::ExprSet {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprListCompId;

impl ruff_text_size::Ranged for crate::ExprListComp {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprSetCompId;

impl ruff_text_size::Ranged for crate::ExprSetComp {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprDictCompId;

impl ruff_text_size::Ranged for crate::ExprDictComp {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprGeneratorId;

impl ruff_text_size::Ranged for crate::ExprGenerator {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprAwaitId;

impl ruff_text_size::Ranged for crate::ExprAwait {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprYieldId;

impl ruff_text_size::Ranged for crate::ExprYield {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprYieldFromId;

impl ruff_text_size::Ranged for crate::ExprYieldFrom {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprCompareId;

impl ruff_text_size::Ranged for crate::ExprCompare {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprCallId;

impl ruff_text_size::Ranged for crate::ExprCall {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprFStringId;

impl ruff_text_size::Ranged for crate::ExprFString {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprStringLiteralId;

impl ruff_text_size::Ranged for crate::ExprStringLiteral {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprBytesLiteralId;

impl ruff_text_size::Ranged for crate::ExprBytesLiteral {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprNumberLiteralId;

impl ruff_text_size::Ranged for crate::ExprNumberLiteral {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprBooleanLiteralId;

impl ruff_text_size::Ranged for crate::ExprBooleanLiteral {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprNoneLiteralId;

impl ruff_text_size::Ranged for crate::ExprNoneLiteral {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprEllipsisLiteralId;

impl ruff_text_size::Ranged for crate::ExprEllipsisLiteral {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprAttributeId;

impl ruff_text_size::Ranged for crate::ExprAttribute {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprSubscriptId;

impl ruff_text_size::Ranged for crate::ExprSubscript {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprStarredId;

impl ruff_text_size::Ranged for crate::ExprStarred {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprNameId;

impl ruff_text_size::Ranged for crate::ExprName {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprListId;

impl ruff_text_size::Ranged for crate::ExprList {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprTupleId;

impl ruff_text_size::Ranged for crate::ExprTuple {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprSliceId;

impl ruff_text_size::Ranged for crate::ExprSlice {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExprIpyEscapeCommandId;

impl ruff_text_size::Ranged for crate::ExprIpyEscapeCommand {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ExceptHandlerExceptHandlerId;

impl ruff_text_size::Ranged for crate::ExceptHandlerExceptHandler {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct FStringExpressionElementId;

impl ruff_text_size::Ranged for crate::FStringExpressionElement {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct FStringLiteralElementId;

impl ruff_text_size::Ranged for crate::FStringLiteralElement {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct PatternMatchValueId;

impl ruff_text_size::Ranged for crate::PatternMatchValue {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct PatternMatchSingletonId;

impl ruff_text_size::Ranged for crate::PatternMatchSingleton {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct PatternMatchSequenceId;

impl ruff_text_size::Ranged for crate::PatternMatchSequence {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct PatternMatchMappingId;

impl ruff_text_size::Ranged for crate::PatternMatchMapping {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct PatternMatchClassId;

impl ruff_text_size::Ranged for crate::PatternMatchClass {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct PatternMatchStarId;

impl ruff_text_size::Ranged for crate::PatternMatchStar {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct PatternMatchAsId;

impl ruff_text_size::Ranged for crate::PatternMatchAs {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct PatternMatchOrId;

impl ruff_text_size::Ranged for crate::PatternMatchOr {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct TypeParamTypeVarId;

impl ruff_text_size::Ranged for crate::TypeParamTypeVar {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct TypeParamTypeVarTupleId;

impl ruff_text_size::Ranged for crate::TypeParamTypeVarTuple {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct TypeParamParamSpecId;

impl ruff_text_size::Ranged for crate::TypeParamParamSpec {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct FStringFormatSpecId;

impl ruff_text_size::Ranged for crate::FStringFormatSpec {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct PatternArgumentsId;

impl ruff_text_size::Ranged for crate::PatternArguments {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct PatternKeywordId;

impl ruff_text_size::Ranged for crate::PatternKeyword {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ComprehensionId;

impl ruff_text_size::Ranged for crate::Comprehension {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ArgumentsId;

impl ruff_text_size::Ranged for crate::Arguments {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ParametersId;

impl ruff_text_size::Ranged for crate::Parameters {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ParameterId;

impl ruff_text_size::Ranged for crate::Parameter {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ParameterWithDefaultId;

impl ruff_text_size::Ranged for crate::ParameterWithDefault {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct KeywordId;

impl ruff_text_size::Ranged for crate::Keyword {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct AliasId;

impl ruff_text_size::Ranged for crate::Alias {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct WithItemId;

impl ruff_text_size::Ranged for crate::WithItem {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct MatchCaseId;

impl ruff_text_size::Ranged for crate::MatchCase {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct DecoratorId;

impl ruff_text_size::Ranged for crate::Decorator {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct ElifElseClauseId;

impl ruff_text_size::Ranged for crate::ElifElseClause {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct TypeParamsId;

impl ruff_text_size::Ranged for crate::TypeParams {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct FStringId;

impl ruff_text_size::Ranged for crate::FString {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct StringLiteralId;

impl ruff_text_size::Ranged for crate::StringLiteral {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct BytesLiteralId;

impl ruff_text_size::Ranged for crate::BytesLiteral {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

#[ruff_index::newtype_index]
pub struct IdentifierId;

impl ruff_text_size::Ranged for crate::Identifier {
    fn range(&self) -> ruff_text_size::TextRange {
        self.range
    }
}

/// See also [mod](https://docs.python.org/3/library/ast.html#ast.mod)
#[derive(Clone, Copy, Debug, PartialEq, is_macro::Is)]
pub enum ModId {
    Module(ModModuleId),
    Expression(ModExpressionId),
}

impl From<ModModuleId> for ModId {
    fn from(id: ModModuleId) -> Self {
        Self::Module(id)
    }
}

impl From<ModExpressionId> for ModId {
    fn from(id: ModExpressionId) -> Self {
        Self::Expression(id)
    }
}

/// See also [stmt](https://docs.python.org/3/library/ast.html#ast.stmt)
#[derive(Clone, Copy, Debug, PartialEq, is_macro::Is)]
pub enum StmtId {
    #[is(name = "function_def_stmt")]
    FunctionDef(StmtFunctionDefId),
    #[is(name = "class_def_stmt")]
    ClassDef(StmtClassDefId),
    #[is(name = "return_stmt")]
    Return(StmtReturnId),
    #[is(name = "delete_stmt")]
    Delete(StmtDeleteId),
    #[is(name = "type_alias_stmt")]
    TypeAlias(StmtTypeAliasId),
    #[is(name = "assign_stmt")]
    Assign(StmtAssignId),
    #[is(name = "aug_assign_stmt")]
    AugAssign(StmtAugAssignId),
    #[is(name = "ann_assign_stmt")]
    AnnAssign(StmtAnnAssignId),
    #[is(name = "for_stmt")]
    For(StmtForId),
    #[is(name = "while_stmt")]
    While(StmtWhileId),
    #[is(name = "if_stmt")]
    If(StmtIfId),
    #[is(name = "with_stmt")]
    With(StmtWithId),
    #[is(name = "match_stmt")]
    Match(StmtMatchId),
    #[is(name = "raise_stmt")]
    Raise(StmtRaiseId),
    #[is(name = "try_stmt")]
    Try(StmtTryId),
    #[is(name = "assert_stmt")]
    Assert(StmtAssertId),
    #[is(name = "import_stmt")]
    Import(StmtImportId),
    #[is(name = "import_from_stmt")]
    ImportFrom(StmtImportFromId),
    #[is(name = "global_stmt")]
    Global(StmtGlobalId),
    #[is(name = "nonlocal_stmt")]
    Nonlocal(StmtNonlocalId),
    #[is(name = "expr_stmt")]
    Expr(StmtExprId),
    #[is(name = "pass_stmt")]
    Pass(StmtPassId),
    #[is(name = "break_stmt")]
    Break(StmtBreakId),
    #[is(name = "continue_stmt")]
    Continue(StmtContinueId),
    #[is(name = "ipy_escape_command_stmt")]
    IpyEscapeCommand(StmtIpyEscapeCommandId),
}

impl From<StmtFunctionDefId> for StmtId {
    fn from(id: StmtFunctionDefId) -> Self {
        Self::FunctionDef(id)
    }
}

impl From<StmtClassDefId> for StmtId {
    fn from(id: StmtClassDefId) -> Self {
        Self::ClassDef(id)
    }
}

impl From<StmtReturnId> for StmtId {
    fn from(id: StmtReturnId) -> Self {
        Self::Return(id)
    }
}

impl From<StmtDeleteId> for StmtId {
    fn from(id: StmtDeleteId) -> Self {
        Self::Delete(id)
    }
}

impl From<StmtTypeAliasId> for StmtId {
    fn from(id: StmtTypeAliasId) -> Self {
        Self::TypeAlias(id)
    }
}

impl From<StmtAssignId> for StmtId {
    fn from(id: StmtAssignId) -> Self {
        Self::Assign(id)
    }
}

impl From<StmtAugAssignId> for StmtId {
    fn from(id: StmtAugAssignId) -> Self {
        Self::AugAssign(id)
    }
}

impl From<StmtAnnAssignId> for StmtId {
    fn from(id: StmtAnnAssignId) -> Self {
        Self::AnnAssign(id)
    }
}

impl From<StmtForId> for StmtId {
    fn from(id: StmtForId) -> Self {
        Self::For(id)
    }
}

impl From<StmtWhileId> for StmtId {
    fn from(id: StmtWhileId) -> Self {
        Self::While(id)
    }
}

impl From<StmtIfId> for StmtId {
    fn from(id: StmtIfId) -> Self {
        Self::If(id)
    }
}

impl From<StmtWithId> for StmtId {
    fn from(id: StmtWithId) -> Self {
        Self::With(id)
    }
}

impl From<StmtMatchId> for StmtId {
    fn from(id: StmtMatchId) -> Self {
        Self::Match(id)
    }
}

impl From<StmtRaiseId> for StmtId {
    fn from(id: StmtRaiseId) -> Self {
        Self::Raise(id)
    }
}

impl From<StmtTryId> for StmtId {
    fn from(id: StmtTryId) -> Self {
        Self::Try(id)
    }
}

impl From<StmtAssertId> for StmtId {
    fn from(id: StmtAssertId) -> Self {
        Self::Assert(id)
    }
}

impl From<StmtImportId> for StmtId {
    fn from(id: StmtImportId) -> Self {
        Self::Import(id)
    }
}

impl From<StmtImportFromId> for StmtId {
    fn from(id: StmtImportFromId) -> Self {
        Self::ImportFrom(id)
    }
}

impl From<StmtGlobalId> for StmtId {
    fn from(id: StmtGlobalId) -> Self {
        Self::Global(id)
    }
}

impl From<StmtNonlocalId> for StmtId {
    fn from(id: StmtNonlocalId) -> Self {
        Self::Nonlocal(id)
    }
}

impl From<StmtExprId> for StmtId {
    fn from(id: StmtExprId) -> Self {
        Self::Expr(id)
    }
}

impl From<StmtPassId> for StmtId {
    fn from(id: StmtPassId) -> Self {
        Self::Pass(id)
    }
}

impl From<StmtBreakId> for StmtId {
    fn from(id: StmtBreakId) -> Self {
        Self::Break(id)
    }
}

impl From<StmtContinueId> for StmtId {
    fn from(id: StmtContinueId) -> Self {
        Self::Continue(id)
    }
}

impl From<StmtIpyEscapeCommandId> for StmtId {
    fn from(id: StmtIpyEscapeCommandId) -> Self {
        Self::IpyEscapeCommand(id)
    }
}

/// See also [expr](https://docs.python.org/3/library/ast.html#ast.expr)
#[derive(Clone, Copy, Debug, PartialEq, is_macro::Is)]
pub enum ExprId {
    #[is(name = "bool_op_expr")]
    BoolOp(ExprBoolOpId),
    #[is(name = "named_expr")]
    Named(ExprNamedId),
    #[is(name = "bin_op_expr")]
    BinOp(ExprBinOpId),
    #[is(name = "unary_op_expr")]
    UnaryOp(ExprUnaryOpId),
    #[is(name = "lambda_expr")]
    Lambda(ExprLambdaId),
    #[is(name = "if_expr")]
    If(ExprIfId),
    #[is(name = "dict_expr")]
    Dict(ExprDictId),
    #[is(name = "set_expr")]
    Set(ExprSetId),
    #[is(name = "list_comp_expr")]
    ListComp(ExprListCompId),
    #[is(name = "set_comp_expr")]
    SetComp(ExprSetCompId),
    #[is(name = "dict_comp_expr")]
    DictComp(ExprDictCompId),
    #[is(name = "generator_expr")]
    Generator(ExprGeneratorId),
    #[is(name = "await_expr")]
    Await(ExprAwaitId),
    #[is(name = "yield_expr")]
    Yield(ExprYieldId),
    #[is(name = "yield_from_expr")]
    YieldFrom(ExprYieldFromId),
    #[is(name = "compare_expr")]
    Compare(ExprCompareId),
    #[is(name = "call_expr")]
    Call(ExprCallId),
    #[is(name = "f_string_expr")]
    FString(ExprFStringId),
    #[is(name = "string_literal_expr")]
    StringLiteral(ExprStringLiteralId),
    #[is(name = "bytes_literal_expr")]
    BytesLiteral(ExprBytesLiteralId),
    #[is(name = "number_literal_expr")]
    NumberLiteral(ExprNumberLiteralId),
    #[is(name = "boolean_literal_expr")]
    BooleanLiteral(ExprBooleanLiteralId),
    #[is(name = "none_literal_expr")]
    NoneLiteral(ExprNoneLiteralId),
    #[is(name = "ellipsis_literal_expr")]
    EllipsisLiteral(ExprEllipsisLiteralId),
    #[is(name = "attribute_expr")]
    Attribute(ExprAttributeId),
    #[is(name = "subscript_expr")]
    Subscript(ExprSubscriptId),
    #[is(name = "starred_expr")]
    Starred(ExprStarredId),
    #[is(name = "name_expr")]
    Name(ExprNameId),
    #[is(name = "list_expr")]
    List(ExprListId),
    #[is(name = "tuple_expr")]
    Tuple(ExprTupleId),
    #[is(name = "slice_expr")]
    Slice(ExprSliceId),
    #[is(name = "ipy_escape_command_expr")]
    IpyEscapeCommand(ExprIpyEscapeCommandId),
}

impl From<ExprBoolOpId> for ExprId {
    fn from(id: ExprBoolOpId) -> Self {
        Self::BoolOp(id)
    }
}

impl From<ExprNamedId> for ExprId {
    fn from(id: ExprNamedId) -> Self {
        Self::Named(id)
    }
}

impl From<ExprBinOpId> for ExprId {
    fn from(id: ExprBinOpId) -> Self {
        Self::BinOp(id)
    }
}

impl From<ExprUnaryOpId> for ExprId {
    fn from(id: ExprUnaryOpId) -> Self {
        Self::UnaryOp(id)
    }
}

impl From<ExprLambdaId> for ExprId {
    fn from(id: ExprLambdaId) -> Self {
        Self::Lambda(id)
    }
}

impl From<ExprIfId> for ExprId {
    fn from(id: ExprIfId) -> Self {
        Self::If(id)
    }
}

impl From<ExprDictId> for ExprId {
    fn from(id: ExprDictId) -> Self {
        Self::Dict(id)
    }
}

impl From<ExprSetId> for ExprId {
    fn from(id: ExprSetId) -> Self {
        Self::Set(id)
    }
}

impl From<ExprListCompId> for ExprId {
    fn from(id: ExprListCompId) -> Self {
        Self::ListComp(id)
    }
}

impl From<ExprSetCompId> for ExprId {
    fn from(id: ExprSetCompId) -> Self {
        Self::SetComp(id)
    }
}

impl From<ExprDictCompId> for ExprId {
    fn from(id: ExprDictCompId) -> Self {
        Self::DictComp(id)
    }
}

impl From<ExprGeneratorId> for ExprId {
    fn from(id: ExprGeneratorId) -> Self {
        Self::Generator(id)
    }
}

impl From<ExprAwaitId> for ExprId {
    fn from(id: ExprAwaitId) -> Self {
        Self::Await(id)
    }
}

impl From<ExprYieldId> for ExprId {
    fn from(id: ExprYieldId) -> Self {
        Self::Yield(id)
    }
}

impl From<ExprYieldFromId> for ExprId {
    fn from(id: ExprYieldFromId) -> Self {
        Self::YieldFrom(id)
    }
}

impl From<ExprCompareId> for ExprId {
    fn from(id: ExprCompareId) -> Self {
        Self::Compare(id)
    }
}

impl From<ExprCallId> for ExprId {
    fn from(id: ExprCallId) -> Self {
        Self::Call(id)
    }
}

impl From<ExprFStringId> for ExprId {
    fn from(id: ExprFStringId) -> Self {
        Self::FString(id)
    }
}

impl From<ExprStringLiteralId> for ExprId {
    fn from(id: ExprStringLiteralId) -> Self {
        Self::StringLiteral(id)
    }
}

impl From<ExprBytesLiteralId> for ExprId {
    fn from(id: ExprBytesLiteralId) -> Self {
        Self::BytesLiteral(id)
    }
}

impl From<ExprNumberLiteralId> for ExprId {
    fn from(id: ExprNumberLiteralId) -> Self {
        Self::NumberLiteral(id)
    }
}

impl From<ExprBooleanLiteralId> for ExprId {
    fn from(id: ExprBooleanLiteralId) -> Self {
        Self::BooleanLiteral(id)
    }
}

impl From<ExprNoneLiteralId> for ExprId {
    fn from(id: ExprNoneLiteralId) -> Self {
        Self::NoneLiteral(id)
    }
}

impl From<ExprEllipsisLiteralId> for ExprId {
    fn from(id: ExprEllipsisLiteralId) -> Self {
        Self::EllipsisLiteral(id)
    }
}

impl From<ExprAttributeId> for ExprId {
    fn from(id: ExprAttributeId) -> Self {
        Self::Attribute(id)
    }
}

impl From<ExprSubscriptId> for ExprId {
    fn from(id: ExprSubscriptId) -> Self {
        Self::Subscript(id)
    }
}

impl From<ExprStarredId> for ExprId {
    fn from(id: ExprStarredId) -> Self {
        Self::Starred(id)
    }
}

impl From<ExprNameId> for ExprId {
    fn from(id: ExprNameId) -> Self {
        Self::Name(id)
    }
}

impl From<ExprListId> for ExprId {
    fn from(id: ExprListId) -> Self {
        Self::List(id)
    }
}

impl From<ExprTupleId> for ExprId {
    fn from(id: ExprTupleId) -> Self {
        Self::Tuple(id)
    }
}

impl From<ExprSliceId> for ExprId {
    fn from(id: ExprSliceId) -> Self {
        Self::Slice(id)
    }
}

impl From<ExprIpyEscapeCommandId> for ExprId {
    fn from(id: ExprIpyEscapeCommandId) -> Self {
        Self::IpyEscapeCommand(id)
    }
}

/// See also [excepthandler](https://docs.python.org/3/library/ast.html#ast.excepthandler)
#[derive(Clone, Copy, Debug, PartialEq, is_macro::Is)]
pub enum ExceptHandlerId {
    ExceptHandler(ExceptHandlerExceptHandlerId),
}

impl From<ExceptHandlerExceptHandlerId> for ExceptHandlerId {
    fn from(id: ExceptHandlerExceptHandlerId) -> Self {
        Self::ExceptHandler(id)
    }
}

#[derive(Clone, Copy, Debug, PartialEq, is_macro::Is)]
pub enum FStringElementId {
    Expression(FStringExpressionElementId),
    Literal(FStringLiteralElementId),
}

impl From<FStringExpressionElementId> for FStringElementId {
    fn from(id: FStringExpressionElementId) -> Self {
        Self::Expression(id)
    }
}

impl From<FStringLiteralElementId> for FStringElementId {
    fn from(id: FStringLiteralElementId) -> Self {
        Self::Literal(id)
    }
}

/// See also [pattern](https://docs.python.org/3/library/ast.html#ast.pattern)
#[derive(Clone, Copy, Debug, PartialEq, is_macro::Is)]
pub enum PatternId {
    MatchValue(PatternMatchValueId),
    MatchSingleton(PatternMatchSingletonId),
    MatchSequence(PatternMatchSequenceId),
    MatchMapping(PatternMatchMappingId),
    MatchClass(PatternMatchClassId),
    MatchStar(PatternMatchStarId),
    MatchAs(PatternMatchAsId),
    MatchOr(PatternMatchOrId),
}

impl From<PatternMatchValueId> for PatternId {
    fn from(id: PatternMatchValueId) -> Self {
        Self::MatchValue(id)
    }
}

impl From<PatternMatchSingletonId> for PatternId {
    fn from(id: PatternMatchSingletonId) -> Self {
        Self::MatchSingleton(id)
    }
}

impl From<PatternMatchSequenceId> for PatternId {
    fn from(id: PatternMatchSequenceId) -> Self {
        Self::MatchSequence(id)
    }
}

impl From<PatternMatchMappingId> for PatternId {
    fn from(id: PatternMatchMappingId) -> Self {
        Self::MatchMapping(id)
    }
}

impl From<PatternMatchClassId> for PatternId {
    fn from(id: PatternMatchClassId) -> Self {
        Self::MatchClass(id)
    }
}

impl From<PatternMatchStarId> for PatternId {
    fn from(id: PatternMatchStarId) -> Self {
        Self::MatchStar(id)
    }
}

impl From<PatternMatchAsId> for PatternId {
    fn from(id: PatternMatchAsId) -> Self {
        Self::MatchAs(id)
    }
}

impl From<PatternMatchOrId> for PatternId {
    fn from(id: PatternMatchOrId) -> Self {
        Self::MatchOr(id)
    }
}

/// See also [type_param](https://docs.python.org/3/library/ast.html#ast.type_param)
#[derive(Clone, Copy, Debug, PartialEq, is_macro::Is)]
pub enum TypeParamId {
    TypeVar(TypeParamTypeVarId),
    TypeVarTuple(TypeParamTypeVarTupleId),
    ParamSpec(TypeParamParamSpecId),
}

impl From<TypeParamTypeVarId> for TypeParamId {
    fn from(id: TypeParamTypeVarId) -> Self {
        Self::TypeVar(id)
    }
}

impl From<TypeParamTypeVarTupleId> for TypeParamId {
    fn from(id: TypeParamTypeVarTupleId) -> Self {
        Self::TypeVarTuple(id)
    }
}

impl From<TypeParamParamSpecId> for TypeParamId {
    fn from(id: TypeParamParamSpecId) -> Self {
        Self::ParamSpec(id)
    }
}

/// See also [mod](https://docs.python.org/3/library/ast.html#ast.mod)
#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum Mod {
    Module(crate::ModModule),
    Expression(crate::ModExpression),
}

impl From<crate::ModModule> for Mod {
    fn from(node: crate::ModModule) -> Self {
        Self::Module(node)
    }
}

impl From<crate::ModExpression> for Mod {
    fn from(node: crate::ModExpression) -> Self {
        Self::Expression(node)
    }
}

impl ruff_text_size::Ranged for Mod {
    fn range(&self) -> ruff_text_size::TextRange {
        match self {
            Self::Module(node) => node.range(),
            Self::Expression(node) => node.range(),
        }
    }
}

/// See also [stmt](https://docs.python.org/3/library/ast.html#ast.stmt)
#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum Stmt {
    #[is(name = "function_def_stmt")]
    FunctionDef(crate::StmtFunctionDef),
    #[is(name = "class_def_stmt")]
    ClassDef(crate::StmtClassDef),
    #[is(name = "return_stmt")]
    Return(crate::StmtReturn),
    #[is(name = "delete_stmt")]
    Delete(crate::StmtDelete),
    #[is(name = "type_alias_stmt")]
    TypeAlias(crate::StmtTypeAlias),
    #[is(name = "assign_stmt")]
    Assign(crate::StmtAssign),
    #[is(name = "aug_assign_stmt")]
    AugAssign(crate::StmtAugAssign),
    #[is(name = "ann_assign_stmt")]
    AnnAssign(crate::StmtAnnAssign),
    #[is(name = "for_stmt")]
    For(crate::StmtFor),
    #[is(name = "while_stmt")]
    While(crate::StmtWhile),
    #[is(name = "if_stmt")]
    If(crate::StmtIf),
    #[is(name = "with_stmt")]
    With(crate::StmtWith),
    #[is(name = "match_stmt")]
    Match(crate::StmtMatch),
    #[is(name = "raise_stmt")]
    Raise(crate::StmtRaise),
    #[is(name = "try_stmt")]
    Try(crate::StmtTry),
    #[is(name = "assert_stmt")]
    Assert(crate::StmtAssert),
    #[is(name = "import_stmt")]
    Import(crate::StmtImport),
    #[is(name = "import_from_stmt")]
    ImportFrom(crate::StmtImportFrom),
    #[is(name = "global_stmt")]
    Global(crate::StmtGlobal),
    #[is(name = "nonlocal_stmt")]
    Nonlocal(crate::StmtNonlocal),
    #[is(name = "expr_stmt")]
    Expr(crate::StmtExpr),
    #[is(name = "pass_stmt")]
    Pass(crate::StmtPass),
    #[is(name = "break_stmt")]
    Break(crate::StmtBreak),
    #[is(name = "continue_stmt")]
    Continue(crate::StmtContinue),
    #[is(name = "ipy_escape_command_stmt")]
    IpyEscapeCommand(crate::StmtIpyEscapeCommand),
}

impl From<crate::StmtFunctionDef> for Stmt {
    fn from(node: crate::StmtFunctionDef) -> Self {
        Self::FunctionDef(node)
    }
}

impl From<crate::StmtClassDef> for Stmt {
    fn from(node: crate::StmtClassDef) -> Self {
        Self::ClassDef(node)
    }
}

impl From<crate::StmtReturn> for Stmt {
    fn from(node: crate::StmtReturn) -> Self {
        Self::Return(node)
    }
}

impl From<crate::StmtDelete> for Stmt {
    fn from(node: crate::StmtDelete) -> Self {
        Self::Delete(node)
    }
}

impl From<crate::StmtTypeAlias> for Stmt {
    fn from(node: crate::StmtTypeAlias) -> Self {
        Self::TypeAlias(node)
    }
}

impl From<crate::StmtAssign> for Stmt {
    fn from(node: crate::StmtAssign) -> Self {
        Self::Assign(node)
    }
}

impl From<crate::StmtAugAssign> for Stmt {
    fn from(node: crate::StmtAugAssign) -> Self {
        Self::AugAssign(node)
    }
}

impl From<crate::StmtAnnAssign> for Stmt {
    fn from(node: crate::StmtAnnAssign) -> Self {
        Self::AnnAssign(node)
    }
}

impl From<crate::StmtFor> for Stmt {
    fn from(node: crate::StmtFor) -> Self {
        Self::For(node)
    }
}

impl From<crate::StmtWhile> for Stmt {
    fn from(node: crate::StmtWhile) -> Self {
        Self::While(node)
    }
}

impl From<crate::StmtIf> for Stmt {
    fn from(node: crate::StmtIf) -> Self {
        Self::If(node)
    }
}

impl From<crate::StmtWith> for Stmt {
    fn from(node: crate::StmtWith) -> Self {
        Self::With(node)
    }
}

impl From<crate::StmtMatch> for Stmt {
    fn from(node: crate::StmtMatch) -> Self {
        Self::Match(node)
    }
}

impl From<crate::StmtRaise> for Stmt {
    fn from(node: crate::StmtRaise) -> Self {
        Self::Raise(node)
    }
}

impl From<crate::StmtTry> for Stmt {
    fn from(node: crate::StmtTry) -> Self {
        Self::Try(node)
    }
}

impl From<crate::StmtAssert> for Stmt {
    fn from(node: crate::StmtAssert) -> Self {
        Self::Assert(node)
    }
}

impl From<crate::StmtImport> for Stmt {
    fn from(node: crate::StmtImport) -> Self {
        Self::Import(node)
    }
}

impl From<crate::StmtImportFrom> for Stmt {
    fn from(node: crate::StmtImportFrom) -> Self {
        Self::ImportFrom(node)
    }
}

impl From<crate::StmtGlobal> for Stmt {
    fn from(node: crate::StmtGlobal) -> Self {
        Self::Global(node)
    }
}

impl From<crate::StmtNonlocal> for Stmt {
    fn from(node: crate::StmtNonlocal) -> Self {
        Self::Nonlocal(node)
    }
}

impl From<crate::StmtExpr> for Stmt {
    fn from(node: crate::StmtExpr) -> Self {
        Self::Expr(node)
    }
}

impl From<crate::StmtPass> for Stmt {
    fn from(node: crate::StmtPass) -> Self {
        Self::Pass(node)
    }
}

impl From<crate::StmtBreak> for Stmt {
    fn from(node: crate::StmtBreak) -> Self {
        Self::Break(node)
    }
}

impl From<crate::StmtContinue> for Stmt {
    fn from(node: crate::StmtContinue) -> Self {
        Self::Continue(node)
    }
}

impl From<crate::StmtIpyEscapeCommand> for Stmt {
    fn from(node: crate::StmtIpyEscapeCommand) -> Self {
        Self::IpyEscapeCommand(node)
    }
}

impl ruff_text_size::Ranged for Stmt {
    fn range(&self) -> ruff_text_size::TextRange {
        match self {
            Self::FunctionDef(node) => node.range(),
            Self::ClassDef(node) => node.range(),
            Self::Return(node) => node.range(),
            Self::Delete(node) => node.range(),
            Self::TypeAlias(node) => node.range(),
            Self::Assign(node) => node.range(),
            Self::AugAssign(node) => node.range(),
            Self::AnnAssign(node) => node.range(),
            Self::For(node) => node.range(),
            Self::While(node) => node.range(),
            Self::If(node) => node.range(),
            Self::With(node) => node.range(),
            Self::Match(node) => node.range(),
            Self::Raise(node) => node.range(),
            Self::Try(node) => node.range(),
            Self::Assert(node) => node.range(),
            Self::Import(node) => node.range(),
            Self::ImportFrom(node) => node.range(),
            Self::Global(node) => node.range(),
            Self::Nonlocal(node) => node.range(),
            Self::Expr(node) => node.range(),
            Self::Pass(node) => node.range(),
            Self::Break(node) => node.range(),
            Self::Continue(node) => node.range(),
            Self::IpyEscapeCommand(node) => node.range(),
        }
    }
}

/// See also [expr](https://docs.python.org/3/library/ast.html#ast.expr)
#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum Expr {
    #[is(name = "bool_op_expr")]
    BoolOp(crate::ExprBoolOp),
    #[is(name = "named_expr")]
    Named(crate::ExprNamed),
    #[is(name = "bin_op_expr")]
    BinOp(crate::ExprBinOp),
    #[is(name = "unary_op_expr")]
    UnaryOp(crate::ExprUnaryOp),
    #[is(name = "lambda_expr")]
    Lambda(crate::ExprLambda),
    #[is(name = "if_expr")]
    If(crate::ExprIf),
    #[is(name = "dict_expr")]
    Dict(crate::ExprDict),
    #[is(name = "set_expr")]
    Set(crate::ExprSet),
    #[is(name = "list_comp_expr")]
    ListComp(crate::ExprListComp),
    #[is(name = "set_comp_expr")]
    SetComp(crate::ExprSetComp),
    #[is(name = "dict_comp_expr")]
    DictComp(crate::ExprDictComp),
    #[is(name = "generator_expr")]
    Generator(crate::ExprGenerator),
    #[is(name = "await_expr")]
    Await(crate::ExprAwait),
    #[is(name = "yield_expr")]
    Yield(crate::ExprYield),
    #[is(name = "yield_from_expr")]
    YieldFrom(crate::ExprYieldFrom),
    #[is(name = "compare_expr")]
    Compare(crate::ExprCompare),
    #[is(name = "call_expr")]
    Call(crate::ExprCall),
    #[is(name = "f_string_expr")]
    FString(crate::ExprFString),
    #[is(name = "string_literal_expr")]
    StringLiteral(crate::ExprStringLiteral),
    #[is(name = "bytes_literal_expr")]
    BytesLiteral(crate::ExprBytesLiteral),
    #[is(name = "number_literal_expr")]
    NumberLiteral(crate::ExprNumberLiteral),
    #[is(name = "boolean_literal_expr")]
    BooleanLiteral(crate::ExprBooleanLiteral),
    #[is(name = "none_literal_expr")]
    NoneLiteral(crate::ExprNoneLiteral),
    #[is(name = "ellipsis_literal_expr")]
    EllipsisLiteral(crate::ExprEllipsisLiteral),
    #[is(name = "attribute_expr")]
    Attribute(crate::ExprAttribute),
    #[is(name = "subscript_expr")]
    Subscript(crate::ExprSubscript),
    #[is(name = "starred_expr")]
    Starred(crate::ExprStarred),
    #[is(name = "name_expr")]
    Name(crate::ExprName),
    #[is(name = "list_expr")]
    List(crate::ExprList),
    #[is(name = "tuple_expr")]
    Tuple(crate::ExprTuple),
    #[is(name = "slice_expr")]
    Slice(crate::ExprSlice),
    #[is(name = "ipy_escape_command_expr")]
    IpyEscapeCommand(crate::ExprIpyEscapeCommand),
}

impl From<crate::ExprBoolOp> for Expr {
    fn from(node: crate::ExprBoolOp) -> Self {
        Self::BoolOp(node)
    }
}

impl From<crate::ExprNamed> for Expr {
    fn from(node: crate::ExprNamed) -> Self {
        Self::Named(node)
    }
}

impl From<crate::ExprBinOp> for Expr {
    fn from(node: crate::ExprBinOp) -> Self {
        Self::BinOp(node)
    }
}

impl From<crate::ExprUnaryOp> for Expr {
    fn from(node: crate::ExprUnaryOp) -> Self {
        Self::UnaryOp(node)
    }
}

impl From<crate::ExprLambda> for Expr {
    fn from(node: crate::ExprLambda) -> Self {
        Self::Lambda(node)
    }
}

impl From<crate::ExprIf> for Expr {
    fn from(node: crate::ExprIf) -> Self {
        Self::If(node)
    }
}

impl From<crate::ExprDict> for Expr {
    fn from(node: crate::ExprDict) -> Self {
        Self::Dict(node)
    }
}

impl From<crate::ExprSet> for Expr {
    fn from(node: crate::ExprSet) -> Self {
        Self::Set(node)
    }
}

impl From<crate::ExprListComp> for Expr {
    fn from(node: crate::ExprListComp) -> Self {
        Self::ListComp(node)
    }
}

impl From<crate::ExprSetComp> for Expr {
    fn from(node: crate::ExprSetComp) -> Self {
        Self::SetComp(node)
    }
}

impl From<crate::ExprDictComp> for Expr {
    fn from(node: crate::ExprDictComp) -> Self {
        Self::DictComp(node)
    }
}

impl From<crate::ExprGenerator> for Expr {
    fn from(node: crate::ExprGenerator) -> Self {
        Self::Generator(node)
    }
}

impl From<crate::ExprAwait> for Expr {
    fn from(node: crate::ExprAwait) -> Self {
        Self::Await(node)
    }
}

impl From<crate::ExprYield> for Expr {
    fn from(node: crate::ExprYield) -> Self {
        Self::Yield(node)
    }
}

impl From<crate::ExprYieldFrom> for Expr {
    fn from(node: crate::ExprYieldFrom) -> Self {
        Self::YieldFrom(node)
    }
}

impl From<crate::ExprCompare> for Expr {
    fn from(node: crate::ExprCompare) -> Self {
        Self::Compare(node)
    }
}

impl From<crate::ExprCall> for Expr {
    fn from(node: crate::ExprCall) -> Self {
        Self::Call(node)
    }
}

impl From<crate::ExprFString> for Expr {
    fn from(node: crate::ExprFString) -> Self {
        Self::FString(node)
    }
}

impl From<crate::ExprStringLiteral> for Expr {
    fn from(node: crate::ExprStringLiteral) -> Self {
        Self::StringLiteral(node)
    }
}

impl From<crate::ExprBytesLiteral> for Expr {
    fn from(node: crate::ExprBytesLiteral) -> Self {
        Self::BytesLiteral(node)
    }
}

impl From<crate::ExprNumberLiteral> for Expr {
    fn from(node: crate::ExprNumberLiteral) -> Self {
        Self::NumberLiteral(node)
    }
}

impl From<crate::ExprBooleanLiteral> for Expr {
    fn from(node: crate::ExprBooleanLiteral) -> Self {
        Self::BooleanLiteral(node)
    }
}

impl From<crate::ExprNoneLiteral> for Expr {
    fn from(node: crate::ExprNoneLiteral) -> Self {
        Self::NoneLiteral(node)
    }
}

impl From<crate::ExprEllipsisLiteral> for Expr {
    fn from(node: crate::ExprEllipsisLiteral) -> Self {
        Self::EllipsisLiteral(node)
    }
}

impl From<crate::ExprAttribute> for Expr {
    fn from(node: crate::ExprAttribute) -> Self {
        Self::Attribute(node)
    }
}

impl From<crate::ExprSubscript> for Expr {
    fn from(node: crate::ExprSubscript) -> Self {
        Self::Subscript(node)
    }
}

impl From<crate::ExprStarred> for Expr {
    fn from(node: crate::ExprStarred) -> Self {
        Self::Starred(node)
    }
}

impl From<crate::ExprName> for Expr {
    fn from(node: crate::ExprName) -> Self {
        Self::Name(node)
    }
}

impl From<crate::ExprList> for Expr {
    fn from(node: crate::ExprList) -> Self {
        Self::List(node)
    }
}

impl From<crate::ExprTuple> for Expr {
    fn from(node: crate::ExprTuple) -> Self {
        Self::Tuple(node)
    }
}

impl From<crate::ExprSlice> for Expr {
    fn from(node: crate::ExprSlice) -> Self {
        Self::Slice(node)
    }
}

impl From<crate::ExprIpyEscapeCommand> for Expr {
    fn from(node: crate::ExprIpyEscapeCommand) -> Self {
        Self::IpyEscapeCommand(node)
    }
}

impl ruff_text_size::Ranged for Expr {
    fn range(&self) -> ruff_text_size::TextRange {
        match self {
            Self::BoolOp(node) => node.range(),
            Self::Named(node) => node.range(),
            Self::BinOp(node) => node.range(),
            Self::UnaryOp(node) => node.range(),
            Self::Lambda(node) => node.range(),
            Self::If(node) => node.range(),
            Self::Dict(node) => node.range(),
            Self::Set(node) => node.range(),
            Self::ListComp(node) => node.range(),
            Self::SetComp(node) => node.range(),
            Self::DictComp(node) => node.range(),
            Self::Generator(node) => node.range(),
            Self::Await(node) => node.range(),
            Self::Yield(node) => node.range(),
            Self::YieldFrom(node) => node.range(),
            Self::Compare(node) => node.range(),
            Self::Call(node) => node.range(),
            Self::FString(node) => node.range(),
            Self::StringLiteral(node) => node.range(),
            Self::BytesLiteral(node) => node.range(),
            Self::NumberLiteral(node) => node.range(),
            Self::BooleanLiteral(node) => node.range(),
            Self::NoneLiteral(node) => node.range(),
            Self::EllipsisLiteral(node) => node.range(),
            Self::Attribute(node) => node.range(),
            Self::Subscript(node) => node.range(),
            Self::Starred(node) => node.range(),
            Self::Name(node) => node.range(),
            Self::List(node) => node.range(),
            Self::Tuple(node) => node.range(),
            Self::Slice(node) => node.range(),
            Self::IpyEscapeCommand(node) => node.range(),
        }
    }
}

/// See also [excepthandler](https://docs.python.org/3/library/ast.html#ast.excepthandler)
#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum ExceptHandler {
    ExceptHandler(crate::ExceptHandlerExceptHandler),
}

impl From<crate::ExceptHandlerExceptHandler> for ExceptHandler {
    fn from(node: crate::ExceptHandlerExceptHandler) -> Self {
        Self::ExceptHandler(node)
    }
}

impl ruff_text_size::Ranged for ExceptHandler {
    fn range(&self) -> ruff_text_size::TextRange {
        match self {
            Self::ExceptHandler(node) => node.range(),
        }
    }
}

#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum FStringElement {
    Expression(crate::FStringExpressionElement),
    Literal(crate::FStringLiteralElement),
}

impl From<crate::FStringExpressionElement> for FStringElement {
    fn from(node: crate::FStringExpressionElement) -> Self {
        Self::Expression(node)
    }
}

impl From<crate::FStringLiteralElement> for FStringElement {
    fn from(node: crate::FStringLiteralElement) -> Self {
        Self::Literal(node)
    }
}

impl ruff_text_size::Ranged for FStringElement {
    fn range(&self) -> ruff_text_size::TextRange {
        match self {
            Self::Expression(node) => node.range(),
            Self::Literal(node) => node.range(),
        }
    }
}

/// See also [pattern](https://docs.python.org/3/library/ast.html#ast.pattern)
#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum Pattern {
    MatchValue(crate::PatternMatchValue),
    MatchSingleton(crate::PatternMatchSingleton),
    MatchSequence(crate::PatternMatchSequence),
    MatchMapping(crate::PatternMatchMapping),
    MatchClass(crate::PatternMatchClass),
    MatchStar(crate::PatternMatchStar),
    MatchAs(crate::PatternMatchAs),
    MatchOr(crate::PatternMatchOr),
}

impl From<crate::PatternMatchValue> for Pattern {
    fn from(node: crate::PatternMatchValue) -> Self {
        Self::MatchValue(node)
    }
}

impl From<crate::PatternMatchSingleton> for Pattern {
    fn from(node: crate::PatternMatchSingleton) -> Self {
        Self::MatchSingleton(node)
    }
}

impl From<crate::PatternMatchSequence> for Pattern {
    fn from(node: crate::PatternMatchSequence) -> Self {
        Self::MatchSequence(node)
    }
}

impl From<crate::PatternMatchMapping> for Pattern {
    fn from(node: crate::PatternMatchMapping) -> Self {
        Self::MatchMapping(node)
    }
}

impl From<crate::PatternMatchClass> for Pattern {
    fn from(node: crate::PatternMatchClass) -> Self {
        Self::MatchClass(node)
    }
}

impl From<crate::PatternMatchStar> for Pattern {
    fn from(node: crate::PatternMatchStar) -> Self {
        Self::MatchStar(node)
    }
}

impl From<crate::PatternMatchAs> for Pattern {
    fn from(node: crate::PatternMatchAs) -> Self {
        Self::MatchAs(node)
    }
}

impl From<crate::PatternMatchOr> for Pattern {
    fn from(node: crate::PatternMatchOr) -> Self {
        Self::MatchOr(node)
    }
}

impl ruff_text_size::Ranged for Pattern {
    fn range(&self) -> ruff_text_size::TextRange {
        match self {
            Self::MatchValue(node) => node.range(),
            Self::MatchSingleton(node) => node.range(),
            Self::MatchSequence(node) => node.range(),
            Self::MatchMapping(node) => node.range(),
            Self::MatchClass(node) => node.range(),
            Self::MatchStar(node) => node.range(),
            Self::MatchAs(node) => node.range(),
            Self::MatchOr(node) => node.range(),
        }
    }
}

/// See also [type_param](https://docs.python.org/3/library/ast.html#ast.type_param)
#[derive(Clone, Debug, PartialEq, is_macro::Is)]
pub enum TypeParam {
    TypeVar(crate::TypeParamTypeVar),
    TypeVarTuple(crate::TypeParamTypeVarTuple),
    ParamSpec(crate::TypeParamParamSpec),
}

impl From<crate::TypeParamTypeVar> for TypeParam {
    fn from(node: crate::TypeParamTypeVar) -> Self {
        Self::TypeVar(node)
    }
}

impl From<crate::TypeParamTypeVarTuple> for TypeParam {
    fn from(node: crate::TypeParamTypeVarTuple) -> Self {
        Self::TypeVarTuple(node)
    }
}

impl From<crate::TypeParamParamSpec> for TypeParam {
    fn from(node: crate::TypeParamParamSpec) -> Self {
        Self::ParamSpec(node)
    }
}

impl ruff_text_size::Ranged for TypeParam {
    fn range(&self) -> ruff_text_size::TextRange {
        match self {
            Self::TypeVar(node) => node.range(),
            Self::TypeVarTuple(node) => node.range(),
            Self::ParamSpec(node) => node.range(),
        }
    }
}

impl Mod {
    #[allow(unused)]
    pub(crate) fn visit_source_order<'a, V>(&'a self, visitor: &mut V)
    where
        V: crate::visitor::source_order::SourceOrderVisitor<'a> + ?Sized,
    {
        match self {
            Mod::Module(node) => node.visit_source_order(visitor),
            Mod::Expression(node) => node.visit_source_order(visitor),
        }
    }
}

impl Stmt {
    #[allow(unused)]
    pub(crate) fn visit_source_order<'a, V>(&'a self, visitor: &mut V)
    where
        V: crate::visitor::source_order::SourceOrderVisitor<'a> + ?Sized,
    {
        match self {
            Stmt::FunctionDef(node) => node.visit_source_order(visitor),
            Stmt::ClassDef(node) => node.visit_source_order(visitor),
            Stmt::Return(node) => node.visit_source_order(visitor),
            Stmt::Delete(node) => node.visit_source_order(visitor),
            Stmt::TypeAlias(node) => node.visit_source_order(visitor),
            Stmt::Assign(node) => node.visit_source_order(visitor),
            Stmt::AugAssign(node) => node.visit_source_order(visitor),
            Stmt::AnnAssign(node) => node.visit_source_order(visitor),
            Stmt::For(node) => node.visit_source_order(visitor),
            Stmt::While(node) => node.visit_source_order(visitor),
            Stmt::If(node) => node.visit_source_order(visitor),
            Stmt::With(node) => node.visit_source_order(visitor),
            Stmt::Match(node) => node.visit_source_order(visitor),
            Stmt::Raise(node) => node.visit_source_order(visitor),
            Stmt::Try(node) => node.visit_source_order(visitor),
            Stmt::Assert(node) => node.visit_source_order(visitor),
            Stmt::Import(node) => node.visit_source_order(visitor),
            Stmt::ImportFrom(node) => node.visit_source_order(visitor),
            Stmt::Global(node) => node.visit_source_order(visitor),
            Stmt::Nonlocal(node) => node.visit_source_order(visitor),
            Stmt::Expr(node) => node.visit_source_order(visitor),
            Stmt::Pass(node) => node.visit_source_order(visitor),
            Stmt::Break(node) => node.visit_source_order(visitor),
            Stmt::Continue(node) => node.visit_source_order(visitor),
            Stmt::IpyEscapeCommand(node) => node.visit_source_order(visitor),
        }
    }
}

impl Expr {
    #[allow(unused)]
    pub(crate) fn visit_source_order<'a, V>(&'a self, visitor: &mut V)
    where
        V: crate::visitor::source_order::SourceOrderVisitor<'a> + ?Sized,
    {
        match self {
            Expr::BoolOp(node) => node.visit_source_order(visitor),
            Expr::Named(node) => node.visit_source_order(visitor),
            Expr::BinOp(node) => node.visit_source_order(visitor),
            Expr::UnaryOp(node) => node.visit_source_order(visitor),
            Expr::Lambda(node) => node.visit_source_order(visitor),
            Expr::If(node) => node.visit_source_order(visitor),
            Expr::Dict(node) => node.visit_source_order(visitor),
            Expr::Set(node) => node.visit_source_order(visitor),
            Expr::ListComp(node) => node.visit_source_order(visitor),
            Expr::SetComp(node) => node.visit_source_order(visitor),
            Expr::DictComp(node) => node.visit_source_order(visitor),
            Expr::Generator(node) => node.visit_source_order(visitor),
            Expr::Await(node) => node.visit_source_order(visitor),
            Expr::Yield(node) => node.visit_source_order(visitor),
            Expr::YieldFrom(node) => node.visit_source_order(visitor),
            Expr::Compare(node) => node.visit_source_order(visitor),
            Expr::Call(node) => node.visit_source_order(visitor),
            Expr::FString(node) => node.visit_source_order(visitor),
            Expr::StringLiteral(node) => node.visit_source_order(visitor),
            Expr::BytesLiteral(node) => node.visit_source_order(visitor),
            Expr::NumberLiteral(node) => node.visit_source_order(visitor),
            Expr::BooleanLiteral(node) => node.visit_source_order(visitor),
            Expr::NoneLiteral(node) => node.visit_source_order(visitor),
            Expr::EllipsisLiteral(node) => node.visit_source_order(visitor),
            Expr::Attribute(node) => node.visit_source_order(visitor),
            Expr::Subscript(node) => node.visit_source_order(visitor),
            Expr::Starred(node) => node.visit_source_order(visitor),
            Expr::Name(node) => node.visit_source_order(visitor),
            Expr::List(node) => node.visit_source_order(visitor),
            Expr::Tuple(node) => node.visit_source_order(visitor),
            Expr::Slice(node) => node.visit_source_order(visitor),
            Expr::IpyEscapeCommand(node) => node.visit_source_order(visitor),
        }
    }
}

impl ExceptHandler {
    #[allow(unused)]
    pub(crate) fn visit_source_order<'a, V>(&'a self, visitor: &mut V)
    where
        V: crate::visitor::source_order::SourceOrderVisitor<'a> + ?Sized,
    {
        match self {
            ExceptHandler::ExceptHandler(node) => node.visit_source_order(visitor),
        }
    }
}

impl FStringElement {
    #[allow(unused)]
    pub(crate) fn visit_source_order<'a, V>(&'a self, visitor: &mut V)
    where
        V: crate::visitor::source_order::SourceOrderVisitor<'a> + ?Sized,
    {
        match self {
            FStringElement::Expression(node) => node.visit_source_order(visitor),
            FStringElement::Literal(node) => node.visit_source_order(visitor),
        }
    }
}

impl Pattern {
    #[allow(unused)]
    pub(crate) fn visit_source_order<'a, V>(&'a self, visitor: &mut V)
    where
        V: crate::visitor::source_order::SourceOrderVisitor<'a> + ?Sized,
    {
        match self {
            Pattern::MatchValue(node) => node.visit_source_order(visitor),
            Pattern::MatchSingleton(node) => node.visit_source_order(visitor),
            Pattern::MatchSequence(node) => node.visit_source_order(visitor),
            Pattern::MatchMapping(node) => node.visit_source_order(visitor),
            Pattern::MatchClass(node) => node.visit_source_order(visitor),
            Pattern::MatchStar(node) => node.visit_source_order(visitor),
            Pattern::MatchAs(node) => node.visit_source_order(visitor),
            Pattern::MatchOr(node) => node.visit_source_order(visitor),
        }
    }
}

impl TypeParam {
    #[allow(unused)]
    pub(crate) fn visit_source_order<'a, V>(&'a self, visitor: &mut V)
    where
        V: crate::visitor::source_order::SourceOrderVisitor<'a> + ?Sized,
    {
        match self {
            TypeParam::TypeVar(node) => node.visit_source_order(visitor),
            TypeParam::TypeVarTuple(node) => node.visit_source_order(visitor),
            TypeParam::ParamSpec(node) => node.visit_source_order(visitor),
        }
    }
}

/// See also [mod](https://docs.python.org/3/library/ast.html#ast.mod)
#[derive(Clone, Copy, Debug, PartialEq, is_macro::Is)]
pub enum ModRef<'a> {
    Module(crate::Node<'a, &'a crate::ModModule>),
    Expression(crate::Node<'a, &'a crate::ModExpression>),
}

impl<'a> From<crate::Node<'a, &'a Mod>> for ModRef<'a> {
    fn from(node: crate::Node<'a, &'a Mod>) -> Self {
        match node.node {
            Mod::Module(n) => ModRef::Module(node.ast.wrap(n)),
            Mod::Expression(n) => ModRef::Expression(node.ast.wrap(n)),
        }
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ModModule>> for ModRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ModModule>) -> Self {
        Self::Module(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ModExpression>> for ModRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ModExpression>) -> Self {
        Self::Expression(node)
    }
}

impl ruff_text_size::Ranged for ModRef<'_> {
    fn range(&self) -> ruff_text_size::TextRange {
        match self {
            Self::Module(node) => node.range(),
            Self::Expression(node) => node.range(),
        }
    }
}

/// See also [stmt](https://docs.python.org/3/library/ast.html#ast.stmt)
#[derive(Clone, Copy, Debug, PartialEq, is_macro::Is)]
pub enum StmtRef<'a> {
    #[is(name = "function_def_stmt")]
    FunctionDef(crate::Node<'a, &'a crate::StmtFunctionDef>),
    #[is(name = "class_def_stmt")]
    ClassDef(crate::Node<'a, &'a crate::StmtClassDef>),
    #[is(name = "return_stmt")]
    Return(crate::Node<'a, &'a crate::StmtReturn>),
    #[is(name = "delete_stmt")]
    Delete(crate::Node<'a, &'a crate::StmtDelete>),
    #[is(name = "type_alias_stmt")]
    TypeAlias(crate::Node<'a, &'a crate::StmtTypeAlias>),
    #[is(name = "assign_stmt")]
    Assign(crate::Node<'a, &'a crate::StmtAssign>),
    #[is(name = "aug_assign_stmt")]
    AugAssign(crate::Node<'a, &'a crate::StmtAugAssign>),
    #[is(name = "ann_assign_stmt")]
    AnnAssign(crate::Node<'a, &'a crate::StmtAnnAssign>),
    #[is(name = "for_stmt")]
    For(crate::Node<'a, &'a crate::StmtFor>),
    #[is(name = "while_stmt")]
    While(crate::Node<'a, &'a crate::StmtWhile>),
    #[is(name = "if_stmt")]
    If(crate::Node<'a, &'a crate::StmtIf>),
    #[is(name = "with_stmt")]
    With(crate::Node<'a, &'a crate::StmtWith>),
    #[is(name = "match_stmt")]
    Match(crate::Node<'a, &'a crate::StmtMatch>),
    #[is(name = "raise_stmt")]
    Raise(crate::Node<'a, &'a crate::StmtRaise>),
    #[is(name = "try_stmt")]
    Try(crate::Node<'a, &'a crate::StmtTry>),
    #[is(name = "assert_stmt")]
    Assert(crate::Node<'a, &'a crate::StmtAssert>),
    #[is(name = "import_stmt")]
    Import(crate::Node<'a, &'a crate::StmtImport>),
    #[is(name = "import_from_stmt")]
    ImportFrom(crate::Node<'a, &'a crate::StmtImportFrom>),
    #[is(name = "global_stmt")]
    Global(crate::Node<'a, &'a crate::StmtGlobal>),
    #[is(name = "nonlocal_stmt")]
    Nonlocal(crate::Node<'a, &'a crate::StmtNonlocal>),
    #[is(name = "expr_stmt")]
    Expr(crate::Node<'a, &'a crate::StmtExpr>),
    #[is(name = "pass_stmt")]
    Pass(crate::Node<'a, &'a crate::StmtPass>),
    #[is(name = "break_stmt")]
    Break(crate::Node<'a, &'a crate::StmtBreak>),
    #[is(name = "continue_stmt")]
    Continue(crate::Node<'a, &'a crate::StmtContinue>),
    #[is(name = "ipy_escape_command_stmt")]
    IpyEscapeCommand(crate::Node<'a, &'a crate::StmtIpyEscapeCommand>),
}

impl<'a> From<crate::Node<'a, &'a Stmt>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a Stmt>) -> Self {
        match node.node {
            Stmt::FunctionDef(n) => StmtRef::FunctionDef(node.ast.wrap(n)),
            Stmt::ClassDef(n) => StmtRef::ClassDef(node.ast.wrap(n)),
            Stmt::Return(n) => StmtRef::Return(node.ast.wrap(n)),
            Stmt::Delete(n) => StmtRef::Delete(node.ast.wrap(n)),
            Stmt::TypeAlias(n) => StmtRef::TypeAlias(node.ast.wrap(n)),
            Stmt::Assign(n) => StmtRef::Assign(node.ast.wrap(n)),
            Stmt::AugAssign(n) => StmtRef::AugAssign(node.ast.wrap(n)),
            Stmt::AnnAssign(n) => StmtRef::AnnAssign(node.ast.wrap(n)),
            Stmt::For(n) => StmtRef::For(node.ast.wrap(n)),
            Stmt::While(n) => StmtRef::While(node.ast.wrap(n)),
            Stmt::If(n) => StmtRef::If(node.ast.wrap(n)),
            Stmt::With(n) => StmtRef::With(node.ast.wrap(n)),
            Stmt::Match(n) => StmtRef::Match(node.ast.wrap(n)),
            Stmt::Raise(n) => StmtRef::Raise(node.ast.wrap(n)),
            Stmt::Try(n) => StmtRef::Try(node.ast.wrap(n)),
            Stmt::Assert(n) => StmtRef::Assert(node.ast.wrap(n)),
            Stmt::Import(n) => StmtRef::Import(node.ast.wrap(n)),
            Stmt::ImportFrom(n) => StmtRef::ImportFrom(node.ast.wrap(n)),
            Stmt::Global(n) => StmtRef::Global(node.ast.wrap(n)),
            Stmt::Nonlocal(n) => StmtRef::Nonlocal(node.ast.wrap(n)),
            Stmt::Expr(n) => StmtRef::Expr(node.ast.wrap(n)),
            Stmt::Pass(n) => StmtRef::Pass(node.ast.wrap(n)),
            Stmt::Break(n) => StmtRef::Break(node.ast.wrap(n)),
            Stmt::Continue(n) => StmtRef::Continue(node.ast.wrap(n)),
            Stmt::IpyEscapeCommand(n) => StmtRef::IpyEscapeCommand(node.ast.wrap(n)),
        }
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtFunctionDef>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtFunctionDef>) -> Self {
        Self::FunctionDef(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtClassDef>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtClassDef>) -> Self {
        Self::ClassDef(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtReturn>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtReturn>) -> Self {
        Self::Return(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtDelete>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtDelete>) -> Self {
        Self::Delete(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtTypeAlias>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtTypeAlias>) -> Self {
        Self::TypeAlias(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtAssign>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtAssign>) -> Self {
        Self::Assign(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtAugAssign>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtAugAssign>) -> Self {
        Self::AugAssign(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtAnnAssign>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtAnnAssign>) -> Self {
        Self::AnnAssign(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtFor>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtFor>) -> Self {
        Self::For(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtWhile>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtWhile>) -> Self {
        Self::While(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtIf>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtIf>) -> Self {
        Self::If(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtWith>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtWith>) -> Self {
        Self::With(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtMatch>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtMatch>) -> Self {
        Self::Match(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtRaise>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtRaise>) -> Self {
        Self::Raise(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtTry>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtTry>) -> Self {
        Self::Try(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtAssert>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtAssert>) -> Self {
        Self::Assert(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtImport>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtImport>) -> Self {
        Self::Import(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtImportFrom>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtImportFrom>) -> Self {
        Self::ImportFrom(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtGlobal>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtGlobal>) -> Self {
        Self::Global(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtNonlocal>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtNonlocal>) -> Self {
        Self::Nonlocal(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtExpr>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtExpr>) -> Self {
        Self::Expr(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtPass>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtPass>) -> Self {
        Self::Pass(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtBreak>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtBreak>) -> Self {
        Self::Break(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtContinue>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtContinue>) -> Self {
        Self::Continue(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtIpyEscapeCommand>> for StmtRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtIpyEscapeCommand>) -> Self {
        Self::IpyEscapeCommand(node)
    }
}

impl ruff_text_size::Ranged for StmtRef<'_> {
    fn range(&self) -> ruff_text_size::TextRange {
        match self {
            Self::FunctionDef(node) => node.range(),
            Self::ClassDef(node) => node.range(),
            Self::Return(node) => node.range(),
            Self::Delete(node) => node.range(),
            Self::TypeAlias(node) => node.range(),
            Self::Assign(node) => node.range(),
            Self::AugAssign(node) => node.range(),
            Self::AnnAssign(node) => node.range(),
            Self::For(node) => node.range(),
            Self::While(node) => node.range(),
            Self::If(node) => node.range(),
            Self::With(node) => node.range(),
            Self::Match(node) => node.range(),
            Self::Raise(node) => node.range(),
            Self::Try(node) => node.range(),
            Self::Assert(node) => node.range(),
            Self::Import(node) => node.range(),
            Self::ImportFrom(node) => node.range(),
            Self::Global(node) => node.range(),
            Self::Nonlocal(node) => node.range(),
            Self::Expr(node) => node.range(),
            Self::Pass(node) => node.range(),
            Self::Break(node) => node.range(),
            Self::Continue(node) => node.range(),
            Self::IpyEscapeCommand(node) => node.range(),
        }
    }
}

/// See also [expr](https://docs.python.org/3/library/ast.html#ast.expr)
#[derive(Clone, Copy, Debug, PartialEq, is_macro::Is)]
pub enum ExprRef<'a> {
    #[is(name = "bool_op_expr")]
    BoolOp(crate::Node<'a, &'a crate::ExprBoolOp>),
    #[is(name = "named_expr")]
    Named(crate::Node<'a, &'a crate::ExprNamed>),
    #[is(name = "bin_op_expr")]
    BinOp(crate::Node<'a, &'a crate::ExprBinOp>),
    #[is(name = "unary_op_expr")]
    UnaryOp(crate::Node<'a, &'a crate::ExprUnaryOp>),
    #[is(name = "lambda_expr")]
    Lambda(crate::Node<'a, &'a crate::ExprLambda>),
    #[is(name = "if_expr")]
    If(crate::Node<'a, &'a crate::ExprIf>),
    #[is(name = "dict_expr")]
    Dict(crate::Node<'a, &'a crate::ExprDict>),
    #[is(name = "set_expr")]
    Set(crate::Node<'a, &'a crate::ExprSet>),
    #[is(name = "list_comp_expr")]
    ListComp(crate::Node<'a, &'a crate::ExprListComp>),
    #[is(name = "set_comp_expr")]
    SetComp(crate::Node<'a, &'a crate::ExprSetComp>),
    #[is(name = "dict_comp_expr")]
    DictComp(crate::Node<'a, &'a crate::ExprDictComp>),
    #[is(name = "generator_expr")]
    Generator(crate::Node<'a, &'a crate::ExprGenerator>),
    #[is(name = "await_expr")]
    Await(crate::Node<'a, &'a crate::ExprAwait>),
    #[is(name = "yield_expr")]
    Yield(crate::Node<'a, &'a crate::ExprYield>),
    #[is(name = "yield_from_expr")]
    YieldFrom(crate::Node<'a, &'a crate::ExprYieldFrom>),
    #[is(name = "compare_expr")]
    Compare(crate::Node<'a, &'a crate::ExprCompare>),
    #[is(name = "call_expr")]
    Call(crate::Node<'a, &'a crate::ExprCall>),
    #[is(name = "f_string_expr")]
    FString(crate::Node<'a, &'a crate::ExprFString>),
    #[is(name = "string_literal_expr")]
    StringLiteral(crate::Node<'a, &'a crate::ExprStringLiteral>),
    #[is(name = "bytes_literal_expr")]
    BytesLiteral(crate::Node<'a, &'a crate::ExprBytesLiteral>),
    #[is(name = "number_literal_expr")]
    NumberLiteral(crate::Node<'a, &'a crate::ExprNumberLiteral>),
    #[is(name = "boolean_literal_expr")]
    BooleanLiteral(crate::Node<'a, &'a crate::ExprBooleanLiteral>),
    #[is(name = "none_literal_expr")]
    NoneLiteral(crate::Node<'a, &'a crate::ExprNoneLiteral>),
    #[is(name = "ellipsis_literal_expr")]
    EllipsisLiteral(crate::Node<'a, &'a crate::ExprEllipsisLiteral>),
    #[is(name = "attribute_expr")]
    Attribute(crate::Node<'a, &'a crate::ExprAttribute>),
    #[is(name = "subscript_expr")]
    Subscript(crate::Node<'a, &'a crate::ExprSubscript>),
    #[is(name = "starred_expr")]
    Starred(crate::Node<'a, &'a crate::ExprStarred>),
    #[is(name = "name_expr")]
    Name(crate::Node<'a, &'a crate::ExprName>),
    #[is(name = "list_expr")]
    List(crate::Node<'a, &'a crate::ExprList>),
    #[is(name = "tuple_expr")]
    Tuple(crate::Node<'a, &'a crate::ExprTuple>),
    #[is(name = "slice_expr")]
    Slice(crate::Node<'a, &'a crate::ExprSlice>),
    #[is(name = "ipy_escape_command_expr")]
    IpyEscapeCommand(crate::Node<'a, &'a crate::ExprIpyEscapeCommand>),
}

impl<'a> From<crate::Node<'a, &'a Expr>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a Expr>) -> Self {
        match node.node {
            Expr::BoolOp(n) => ExprRef::BoolOp(node.ast.wrap(n)),
            Expr::Named(n) => ExprRef::Named(node.ast.wrap(n)),
            Expr::BinOp(n) => ExprRef::BinOp(node.ast.wrap(n)),
            Expr::UnaryOp(n) => ExprRef::UnaryOp(node.ast.wrap(n)),
            Expr::Lambda(n) => ExprRef::Lambda(node.ast.wrap(n)),
            Expr::If(n) => ExprRef::If(node.ast.wrap(n)),
            Expr::Dict(n) => ExprRef::Dict(node.ast.wrap(n)),
            Expr::Set(n) => ExprRef::Set(node.ast.wrap(n)),
            Expr::ListComp(n) => ExprRef::ListComp(node.ast.wrap(n)),
            Expr::SetComp(n) => ExprRef::SetComp(node.ast.wrap(n)),
            Expr::DictComp(n) => ExprRef::DictComp(node.ast.wrap(n)),
            Expr::Generator(n) => ExprRef::Generator(node.ast.wrap(n)),
            Expr::Await(n) => ExprRef::Await(node.ast.wrap(n)),
            Expr::Yield(n) => ExprRef::Yield(node.ast.wrap(n)),
            Expr::YieldFrom(n) => ExprRef::YieldFrom(node.ast.wrap(n)),
            Expr::Compare(n) => ExprRef::Compare(node.ast.wrap(n)),
            Expr::Call(n) => ExprRef::Call(node.ast.wrap(n)),
            Expr::FString(n) => ExprRef::FString(node.ast.wrap(n)),
            Expr::StringLiteral(n) => ExprRef::StringLiteral(node.ast.wrap(n)),
            Expr::BytesLiteral(n) => ExprRef::BytesLiteral(node.ast.wrap(n)),
            Expr::NumberLiteral(n) => ExprRef::NumberLiteral(node.ast.wrap(n)),
            Expr::BooleanLiteral(n) => ExprRef::BooleanLiteral(node.ast.wrap(n)),
            Expr::NoneLiteral(n) => ExprRef::NoneLiteral(node.ast.wrap(n)),
            Expr::EllipsisLiteral(n) => ExprRef::EllipsisLiteral(node.ast.wrap(n)),
            Expr::Attribute(n) => ExprRef::Attribute(node.ast.wrap(n)),
            Expr::Subscript(n) => ExprRef::Subscript(node.ast.wrap(n)),
            Expr::Starred(n) => ExprRef::Starred(node.ast.wrap(n)),
            Expr::Name(n) => ExprRef::Name(node.ast.wrap(n)),
            Expr::List(n) => ExprRef::List(node.ast.wrap(n)),
            Expr::Tuple(n) => ExprRef::Tuple(node.ast.wrap(n)),
            Expr::Slice(n) => ExprRef::Slice(node.ast.wrap(n)),
            Expr::IpyEscapeCommand(n) => ExprRef::IpyEscapeCommand(node.ast.wrap(n)),
        }
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprBoolOp>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprBoolOp>) -> Self {
        Self::BoolOp(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprNamed>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprNamed>) -> Self {
        Self::Named(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprBinOp>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprBinOp>) -> Self {
        Self::BinOp(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprUnaryOp>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprUnaryOp>) -> Self {
        Self::UnaryOp(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprLambda>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprLambda>) -> Self {
        Self::Lambda(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprIf>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprIf>) -> Self {
        Self::If(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprDict>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprDict>) -> Self {
        Self::Dict(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprSet>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprSet>) -> Self {
        Self::Set(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprListComp>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprListComp>) -> Self {
        Self::ListComp(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprSetComp>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprSetComp>) -> Self {
        Self::SetComp(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprDictComp>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprDictComp>) -> Self {
        Self::DictComp(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprGenerator>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprGenerator>) -> Self {
        Self::Generator(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprAwait>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprAwait>) -> Self {
        Self::Await(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprYield>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprYield>) -> Self {
        Self::Yield(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprYieldFrom>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprYieldFrom>) -> Self {
        Self::YieldFrom(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprCompare>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprCompare>) -> Self {
        Self::Compare(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprCall>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprCall>) -> Self {
        Self::Call(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprFString>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprFString>) -> Self {
        Self::FString(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprStringLiteral>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprStringLiteral>) -> Self {
        Self::StringLiteral(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprBytesLiteral>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprBytesLiteral>) -> Self {
        Self::BytesLiteral(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprNumberLiteral>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprNumberLiteral>) -> Self {
        Self::NumberLiteral(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprBooleanLiteral>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprBooleanLiteral>) -> Self {
        Self::BooleanLiteral(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprNoneLiteral>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprNoneLiteral>) -> Self {
        Self::NoneLiteral(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprEllipsisLiteral>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprEllipsisLiteral>) -> Self {
        Self::EllipsisLiteral(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprAttribute>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprAttribute>) -> Self {
        Self::Attribute(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprSubscript>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprSubscript>) -> Self {
        Self::Subscript(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprStarred>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprStarred>) -> Self {
        Self::Starred(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprName>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprName>) -> Self {
        Self::Name(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprList>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprList>) -> Self {
        Self::List(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprTuple>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprTuple>) -> Self {
        Self::Tuple(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprSlice>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprSlice>) -> Self {
        Self::Slice(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprIpyEscapeCommand>> for ExprRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprIpyEscapeCommand>) -> Self {
        Self::IpyEscapeCommand(node)
    }
}

impl ruff_text_size::Ranged for ExprRef<'_> {
    fn range(&self) -> ruff_text_size::TextRange {
        match self {
            Self::BoolOp(node) => node.range(),
            Self::Named(node) => node.range(),
            Self::BinOp(node) => node.range(),
            Self::UnaryOp(node) => node.range(),
            Self::Lambda(node) => node.range(),
            Self::If(node) => node.range(),
            Self::Dict(node) => node.range(),
            Self::Set(node) => node.range(),
            Self::ListComp(node) => node.range(),
            Self::SetComp(node) => node.range(),
            Self::DictComp(node) => node.range(),
            Self::Generator(node) => node.range(),
            Self::Await(node) => node.range(),
            Self::Yield(node) => node.range(),
            Self::YieldFrom(node) => node.range(),
            Self::Compare(node) => node.range(),
            Self::Call(node) => node.range(),
            Self::FString(node) => node.range(),
            Self::StringLiteral(node) => node.range(),
            Self::BytesLiteral(node) => node.range(),
            Self::NumberLiteral(node) => node.range(),
            Self::BooleanLiteral(node) => node.range(),
            Self::NoneLiteral(node) => node.range(),
            Self::EllipsisLiteral(node) => node.range(),
            Self::Attribute(node) => node.range(),
            Self::Subscript(node) => node.range(),
            Self::Starred(node) => node.range(),
            Self::Name(node) => node.range(),
            Self::List(node) => node.range(),
            Self::Tuple(node) => node.range(),
            Self::Slice(node) => node.range(),
            Self::IpyEscapeCommand(node) => node.range(),
        }
    }
}

/// See also [excepthandler](https://docs.python.org/3/library/ast.html#ast.excepthandler)
#[derive(Clone, Copy, Debug, PartialEq, is_macro::Is)]
pub enum ExceptHandlerRef<'a> {
    ExceptHandler(crate::Node<'a, &'a crate::ExceptHandlerExceptHandler>),
}

impl<'a> From<crate::Node<'a, &'a ExceptHandler>> for ExceptHandlerRef<'a> {
    fn from(node: crate::Node<'a, &'a ExceptHandler>) -> Self {
        match node.node {
            ExceptHandler::ExceptHandler(n) => ExceptHandlerRef::ExceptHandler(node.ast.wrap(n)),
        }
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExceptHandlerExceptHandler>> for ExceptHandlerRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExceptHandlerExceptHandler>) -> Self {
        Self::ExceptHandler(node)
    }
}

impl ruff_text_size::Ranged for ExceptHandlerRef<'_> {
    fn range(&self) -> ruff_text_size::TextRange {
        match self {
            Self::ExceptHandler(node) => node.range(),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, is_macro::Is)]
pub enum FStringElementRef<'a> {
    Expression(crate::Node<'a, &'a crate::FStringExpressionElement>),
    Literal(crate::Node<'a, &'a crate::FStringLiteralElement>),
}

impl<'a> From<crate::Node<'a, &'a FStringElement>> for FStringElementRef<'a> {
    fn from(node: crate::Node<'a, &'a FStringElement>) -> Self {
        match node.node {
            FStringElement::Expression(n) => FStringElementRef::Expression(node.ast.wrap(n)),
            FStringElement::Literal(n) => FStringElementRef::Literal(node.ast.wrap(n)),
        }
    }
}

impl<'a> From<crate::Node<'a, &'a crate::FStringExpressionElement>> for FStringElementRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::FStringExpressionElement>) -> Self {
        Self::Expression(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::FStringLiteralElement>> for FStringElementRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::FStringLiteralElement>) -> Self {
        Self::Literal(node)
    }
}

impl ruff_text_size::Ranged for FStringElementRef<'_> {
    fn range(&self) -> ruff_text_size::TextRange {
        match self {
            Self::Expression(node) => node.range(),
            Self::Literal(node) => node.range(),
        }
    }
}

/// See also [pattern](https://docs.python.org/3/library/ast.html#ast.pattern)
#[derive(Clone, Copy, Debug, PartialEq, is_macro::Is)]
pub enum PatternRef<'a> {
    MatchValue(crate::Node<'a, &'a crate::PatternMatchValue>),
    MatchSingleton(crate::Node<'a, &'a crate::PatternMatchSingleton>),
    MatchSequence(crate::Node<'a, &'a crate::PatternMatchSequence>),
    MatchMapping(crate::Node<'a, &'a crate::PatternMatchMapping>),
    MatchClass(crate::Node<'a, &'a crate::PatternMatchClass>),
    MatchStar(crate::Node<'a, &'a crate::PatternMatchStar>),
    MatchAs(crate::Node<'a, &'a crate::PatternMatchAs>),
    MatchOr(crate::Node<'a, &'a crate::PatternMatchOr>),
}

impl<'a> From<crate::Node<'a, &'a Pattern>> for PatternRef<'a> {
    fn from(node: crate::Node<'a, &'a Pattern>) -> Self {
        match node.node {
            Pattern::MatchValue(n) => PatternRef::MatchValue(node.ast.wrap(n)),
            Pattern::MatchSingleton(n) => PatternRef::MatchSingleton(node.ast.wrap(n)),
            Pattern::MatchSequence(n) => PatternRef::MatchSequence(node.ast.wrap(n)),
            Pattern::MatchMapping(n) => PatternRef::MatchMapping(node.ast.wrap(n)),
            Pattern::MatchClass(n) => PatternRef::MatchClass(node.ast.wrap(n)),
            Pattern::MatchStar(n) => PatternRef::MatchStar(node.ast.wrap(n)),
            Pattern::MatchAs(n) => PatternRef::MatchAs(node.ast.wrap(n)),
            Pattern::MatchOr(n) => PatternRef::MatchOr(node.ast.wrap(n)),
        }
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternMatchValue>> for PatternRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternMatchValue>) -> Self {
        Self::MatchValue(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternMatchSingleton>> for PatternRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternMatchSingleton>) -> Self {
        Self::MatchSingleton(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternMatchSequence>> for PatternRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternMatchSequence>) -> Self {
        Self::MatchSequence(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternMatchMapping>> for PatternRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternMatchMapping>) -> Self {
        Self::MatchMapping(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternMatchClass>> for PatternRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternMatchClass>) -> Self {
        Self::MatchClass(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternMatchStar>> for PatternRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternMatchStar>) -> Self {
        Self::MatchStar(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternMatchAs>> for PatternRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternMatchAs>) -> Self {
        Self::MatchAs(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternMatchOr>> for PatternRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternMatchOr>) -> Self {
        Self::MatchOr(node)
    }
}

impl ruff_text_size::Ranged for PatternRef<'_> {
    fn range(&self) -> ruff_text_size::TextRange {
        match self {
            Self::MatchValue(node) => node.range(),
            Self::MatchSingleton(node) => node.range(),
            Self::MatchSequence(node) => node.range(),
            Self::MatchMapping(node) => node.range(),
            Self::MatchClass(node) => node.range(),
            Self::MatchStar(node) => node.range(),
            Self::MatchAs(node) => node.range(),
            Self::MatchOr(node) => node.range(),
        }
    }
}

/// See also [type_param](https://docs.python.org/3/library/ast.html#ast.type_param)
#[derive(Clone, Copy, Debug, PartialEq, is_macro::Is)]
pub enum TypeParamRef<'a> {
    TypeVar(crate::Node<'a, &'a crate::TypeParamTypeVar>),
    TypeVarTuple(crate::Node<'a, &'a crate::TypeParamTypeVarTuple>),
    ParamSpec(crate::Node<'a, &'a crate::TypeParamParamSpec>),
}

impl<'a> From<crate::Node<'a, &'a TypeParam>> for TypeParamRef<'a> {
    fn from(node: crate::Node<'a, &'a TypeParam>) -> Self {
        match node.node {
            TypeParam::TypeVar(n) => TypeParamRef::TypeVar(node.ast.wrap(n)),
            TypeParam::TypeVarTuple(n) => TypeParamRef::TypeVarTuple(node.ast.wrap(n)),
            TypeParam::ParamSpec(n) => TypeParamRef::ParamSpec(node.ast.wrap(n)),
        }
    }
}

impl<'a> From<crate::Node<'a, &'a crate::TypeParamTypeVar>> for TypeParamRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::TypeParamTypeVar>) -> Self {
        Self::TypeVar(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::TypeParamTypeVarTuple>> for TypeParamRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::TypeParamTypeVarTuple>) -> Self {
        Self::TypeVarTuple(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::TypeParamParamSpec>> for TypeParamRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::TypeParamParamSpec>) -> Self {
        Self::ParamSpec(node)
    }
}

impl ruff_text_size::Ranged for TypeParamRef<'_> {
    fn range(&self) -> ruff_text_size::TextRange {
        match self {
            Self::TypeVar(node) => node.range(),
            Self::TypeVarTuple(node) => node.range(),
            Self::ParamSpec(node) => node.range(),
        }
    }
}

impl<'a> ModRef<'a> {
    #[allow(unused)]
    pub(crate) fn visit_source_order<V>(self, visitor: &mut V)
    where
        V: crate::visitor::source_order::SourceOrderVisitor<'a> + ?Sized,
    {
        match self {
            ModRef::Module(node) => node.visit_source_order(visitor),
            ModRef::Expression(node) => node.visit_source_order(visitor),
        }
    }
}

impl<'a> StmtRef<'a> {
    #[allow(unused)]
    pub(crate) fn visit_source_order<V>(self, visitor: &mut V)
    where
        V: crate::visitor::source_order::SourceOrderVisitor<'a> + ?Sized,
    {
        match self {
            StmtRef::FunctionDef(node) => node.visit_source_order(visitor),
            StmtRef::ClassDef(node) => node.visit_source_order(visitor),
            StmtRef::Return(node) => node.visit_source_order(visitor),
            StmtRef::Delete(node) => node.visit_source_order(visitor),
            StmtRef::TypeAlias(node) => node.visit_source_order(visitor),
            StmtRef::Assign(node) => node.visit_source_order(visitor),
            StmtRef::AugAssign(node) => node.visit_source_order(visitor),
            StmtRef::AnnAssign(node) => node.visit_source_order(visitor),
            StmtRef::For(node) => node.visit_source_order(visitor),
            StmtRef::While(node) => node.visit_source_order(visitor),
            StmtRef::If(node) => node.visit_source_order(visitor),
            StmtRef::With(node) => node.visit_source_order(visitor),
            StmtRef::Match(node) => node.visit_source_order(visitor),
            StmtRef::Raise(node) => node.visit_source_order(visitor),
            StmtRef::Try(node) => node.visit_source_order(visitor),
            StmtRef::Assert(node) => node.visit_source_order(visitor),
            StmtRef::Import(node) => node.visit_source_order(visitor),
            StmtRef::ImportFrom(node) => node.visit_source_order(visitor),
            StmtRef::Global(node) => node.visit_source_order(visitor),
            StmtRef::Nonlocal(node) => node.visit_source_order(visitor),
            StmtRef::Expr(node) => node.visit_source_order(visitor),
            StmtRef::Pass(node) => node.visit_source_order(visitor),
            StmtRef::Break(node) => node.visit_source_order(visitor),
            StmtRef::Continue(node) => node.visit_source_order(visitor),
            StmtRef::IpyEscapeCommand(node) => node.visit_source_order(visitor),
        }
    }
}

impl<'a> ExprRef<'a> {
    #[allow(unused)]
    pub(crate) fn visit_source_order<V>(self, visitor: &mut V)
    where
        V: crate::visitor::source_order::SourceOrderVisitor<'a> + ?Sized,
    {
        match self {
            ExprRef::BoolOp(node) => node.visit_source_order(visitor),
            ExprRef::Named(node) => node.visit_source_order(visitor),
            ExprRef::BinOp(node) => node.visit_source_order(visitor),
            ExprRef::UnaryOp(node) => node.visit_source_order(visitor),
            ExprRef::Lambda(node) => node.visit_source_order(visitor),
            ExprRef::If(node) => node.visit_source_order(visitor),
            ExprRef::Dict(node) => node.visit_source_order(visitor),
            ExprRef::Set(node) => node.visit_source_order(visitor),
            ExprRef::ListComp(node) => node.visit_source_order(visitor),
            ExprRef::SetComp(node) => node.visit_source_order(visitor),
            ExprRef::DictComp(node) => node.visit_source_order(visitor),
            ExprRef::Generator(node) => node.visit_source_order(visitor),
            ExprRef::Await(node) => node.visit_source_order(visitor),
            ExprRef::Yield(node) => node.visit_source_order(visitor),
            ExprRef::YieldFrom(node) => node.visit_source_order(visitor),
            ExprRef::Compare(node) => node.visit_source_order(visitor),
            ExprRef::Call(node) => node.visit_source_order(visitor),
            ExprRef::FString(node) => node.visit_source_order(visitor),
            ExprRef::StringLiteral(node) => node.visit_source_order(visitor),
            ExprRef::BytesLiteral(node) => node.visit_source_order(visitor),
            ExprRef::NumberLiteral(node) => node.visit_source_order(visitor),
            ExprRef::BooleanLiteral(node) => node.visit_source_order(visitor),
            ExprRef::NoneLiteral(node) => node.visit_source_order(visitor),
            ExprRef::EllipsisLiteral(node) => node.visit_source_order(visitor),
            ExprRef::Attribute(node) => node.visit_source_order(visitor),
            ExprRef::Subscript(node) => node.visit_source_order(visitor),
            ExprRef::Starred(node) => node.visit_source_order(visitor),
            ExprRef::Name(node) => node.visit_source_order(visitor),
            ExprRef::List(node) => node.visit_source_order(visitor),
            ExprRef::Tuple(node) => node.visit_source_order(visitor),
            ExprRef::Slice(node) => node.visit_source_order(visitor),
            ExprRef::IpyEscapeCommand(node) => node.visit_source_order(visitor),
        }
    }
}

impl<'a> ExceptHandlerRef<'a> {
    #[allow(unused)]
    pub(crate) fn visit_source_order<V>(self, visitor: &mut V)
    where
        V: crate::visitor::source_order::SourceOrderVisitor<'a> + ?Sized,
    {
        match self {
            ExceptHandlerRef::ExceptHandler(node) => node.visit_source_order(visitor),
        }
    }
}

impl<'a> FStringElementRef<'a> {
    #[allow(unused)]
    pub(crate) fn visit_source_order<V>(self, visitor: &mut V)
    where
        V: crate::visitor::source_order::SourceOrderVisitor<'a> + ?Sized,
    {
        match self {
            FStringElementRef::Expression(node) => node.visit_source_order(visitor),
            FStringElementRef::Literal(node) => node.visit_source_order(visitor),
        }
    }
}

impl<'a> PatternRef<'a> {
    #[allow(unused)]
    pub(crate) fn visit_source_order<V>(self, visitor: &mut V)
    where
        V: crate::visitor::source_order::SourceOrderVisitor<'a> + ?Sized,
    {
        match self {
            PatternRef::MatchValue(node) => node.visit_source_order(visitor),
            PatternRef::MatchSingleton(node) => node.visit_source_order(visitor),
            PatternRef::MatchSequence(node) => node.visit_source_order(visitor),
            PatternRef::MatchMapping(node) => node.visit_source_order(visitor),
            PatternRef::MatchClass(node) => node.visit_source_order(visitor),
            PatternRef::MatchStar(node) => node.visit_source_order(visitor),
            PatternRef::MatchAs(node) => node.visit_source_order(visitor),
            PatternRef::MatchOr(node) => node.visit_source_order(visitor),
        }
    }
}

impl<'a> TypeParamRef<'a> {
    #[allow(unused)]
    pub(crate) fn visit_source_order<V>(self, visitor: &mut V)
    where
        V: crate::visitor::source_order::SourceOrderVisitor<'a> + ?Sized,
    {
        match self {
            TypeParamRef::TypeVar(node) => node.visit_source_order(visitor),
            TypeParamRef::TypeVarTuple(node) => node.visit_source_order(visitor),
            TypeParamRef::ParamSpec(node) => node.visit_source_order(visitor),
        }
    }
}

#[derive(Clone, Default, PartialEq)]
pub(crate) struct Storage {
    pub(crate) mod_module: ruff_index::IndexVec<ModModuleId, crate::ModModule>,
    pub(crate) mod_expression: ruff_index::IndexVec<ModExpressionId, crate::ModExpression>,
    pub(crate) stmt_function_def: ruff_index::IndexVec<StmtFunctionDefId, crate::StmtFunctionDef>,
    pub(crate) stmt_class_def: ruff_index::IndexVec<StmtClassDefId, crate::StmtClassDef>,
    pub(crate) stmt_return: ruff_index::IndexVec<StmtReturnId, crate::StmtReturn>,
    pub(crate) stmt_delete: ruff_index::IndexVec<StmtDeleteId, crate::StmtDelete>,
    pub(crate) stmt_type_alias: ruff_index::IndexVec<StmtTypeAliasId, crate::StmtTypeAlias>,
    pub(crate) stmt_assign: ruff_index::IndexVec<StmtAssignId, crate::StmtAssign>,
    pub(crate) stmt_aug_assign: ruff_index::IndexVec<StmtAugAssignId, crate::StmtAugAssign>,
    pub(crate) stmt_ann_assign: ruff_index::IndexVec<StmtAnnAssignId, crate::StmtAnnAssign>,
    pub(crate) stmt_for: ruff_index::IndexVec<StmtForId, crate::StmtFor>,
    pub(crate) stmt_while: ruff_index::IndexVec<StmtWhileId, crate::StmtWhile>,
    pub(crate) stmt_if: ruff_index::IndexVec<StmtIfId, crate::StmtIf>,
    pub(crate) stmt_with: ruff_index::IndexVec<StmtWithId, crate::StmtWith>,
    pub(crate) stmt_match: ruff_index::IndexVec<StmtMatchId, crate::StmtMatch>,
    pub(crate) stmt_raise: ruff_index::IndexVec<StmtRaiseId, crate::StmtRaise>,
    pub(crate) stmt_try: ruff_index::IndexVec<StmtTryId, crate::StmtTry>,
    pub(crate) stmt_assert: ruff_index::IndexVec<StmtAssertId, crate::StmtAssert>,
    pub(crate) stmt_import: ruff_index::IndexVec<StmtImportId, crate::StmtImport>,
    pub(crate) stmt_import_from: ruff_index::IndexVec<StmtImportFromId, crate::StmtImportFrom>,
    pub(crate) stmt_global: ruff_index::IndexVec<StmtGlobalId, crate::StmtGlobal>,
    pub(crate) stmt_nonlocal: ruff_index::IndexVec<StmtNonlocalId, crate::StmtNonlocal>,
    pub(crate) stmt_expr: ruff_index::IndexVec<StmtExprId, crate::StmtExpr>,
    pub(crate) stmt_pass: ruff_index::IndexVec<StmtPassId, crate::StmtPass>,
    pub(crate) stmt_break: ruff_index::IndexVec<StmtBreakId, crate::StmtBreak>,
    pub(crate) stmt_continue: ruff_index::IndexVec<StmtContinueId, crate::StmtContinue>,
    pub(crate) stmt_ipy_escape_command:
        ruff_index::IndexVec<StmtIpyEscapeCommandId, crate::StmtIpyEscapeCommand>,
    pub(crate) expr_bool_op: ruff_index::IndexVec<ExprBoolOpId, crate::ExprBoolOp>,
    pub(crate) expr_named: ruff_index::IndexVec<ExprNamedId, crate::ExprNamed>,
    pub(crate) expr_bin_op: ruff_index::IndexVec<ExprBinOpId, crate::ExprBinOp>,
    pub(crate) expr_unary_op: ruff_index::IndexVec<ExprUnaryOpId, crate::ExprUnaryOp>,
    pub(crate) expr_lambda: ruff_index::IndexVec<ExprLambdaId, crate::ExprLambda>,
    pub(crate) expr_if: ruff_index::IndexVec<ExprIfId, crate::ExprIf>,
    pub(crate) expr_dict: ruff_index::IndexVec<ExprDictId, crate::ExprDict>,
    pub(crate) expr_set: ruff_index::IndexVec<ExprSetId, crate::ExprSet>,
    pub(crate) expr_list_comp: ruff_index::IndexVec<ExprListCompId, crate::ExprListComp>,
    pub(crate) expr_set_comp: ruff_index::IndexVec<ExprSetCompId, crate::ExprSetComp>,
    pub(crate) expr_dict_comp: ruff_index::IndexVec<ExprDictCompId, crate::ExprDictComp>,
    pub(crate) expr_generator: ruff_index::IndexVec<ExprGeneratorId, crate::ExprGenerator>,
    pub(crate) expr_await: ruff_index::IndexVec<ExprAwaitId, crate::ExprAwait>,
    pub(crate) expr_yield: ruff_index::IndexVec<ExprYieldId, crate::ExprYield>,
    pub(crate) expr_yield_from: ruff_index::IndexVec<ExprYieldFromId, crate::ExprYieldFrom>,
    pub(crate) expr_compare: ruff_index::IndexVec<ExprCompareId, crate::ExprCompare>,
    pub(crate) expr_call: ruff_index::IndexVec<ExprCallId, crate::ExprCall>,
    pub(crate) expr_f_string: ruff_index::IndexVec<ExprFStringId, crate::ExprFString>,
    pub(crate) expr_string_literal:
        ruff_index::IndexVec<ExprStringLiteralId, crate::ExprStringLiteral>,
    pub(crate) expr_bytes_literal:
        ruff_index::IndexVec<ExprBytesLiteralId, crate::ExprBytesLiteral>,
    pub(crate) expr_number_literal:
        ruff_index::IndexVec<ExprNumberLiteralId, crate::ExprNumberLiteral>,
    pub(crate) expr_boolean_literal:
        ruff_index::IndexVec<ExprBooleanLiteralId, crate::ExprBooleanLiteral>,
    pub(crate) expr_none_literal: ruff_index::IndexVec<ExprNoneLiteralId, crate::ExprNoneLiteral>,
    pub(crate) expr_ellipsis_literal:
        ruff_index::IndexVec<ExprEllipsisLiteralId, crate::ExprEllipsisLiteral>,
    pub(crate) expr_attribute: ruff_index::IndexVec<ExprAttributeId, crate::ExprAttribute>,
    pub(crate) expr_subscript: ruff_index::IndexVec<ExprSubscriptId, crate::ExprSubscript>,
    pub(crate) expr_starred: ruff_index::IndexVec<ExprStarredId, crate::ExprStarred>,
    pub(crate) expr_name: ruff_index::IndexVec<ExprNameId, crate::ExprName>,
    pub(crate) expr_list: ruff_index::IndexVec<ExprListId, crate::ExprList>,
    pub(crate) expr_tuple: ruff_index::IndexVec<ExprTupleId, crate::ExprTuple>,
    pub(crate) expr_slice: ruff_index::IndexVec<ExprSliceId, crate::ExprSlice>,
    pub(crate) expr_ipy_escape_command:
        ruff_index::IndexVec<ExprIpyEscapeCommandId, crate::ExprIpyEscapeCommand>,
    pub(crate) except_handler_except_handler:
        ruff_index::IndexVec<ExceptHandlerExceptHandlerId, crate::ExceptHandlerExceptHandler>,
    pub(crate) f_string_expression_element:
        ruff_index::IndexVec<FStringExpressionElementId, crate::FStringExpressionElement>,
    pub(crate) f_string_literal_element:
        ruff_index::IndexVec<FStringLiteralElementId, crate::FStringLiteralElement>,
    pub(crate) pattern_match_value:
        ruff_index::IndexVec<PatternMatchValueId, crate::PatternMatchValue>,
    pub(crate) pattern_match_singleton:
        ruff_index::IndexVec<PatternMatchSingletonId, crate::PatternMatchSingleton>,
    pub(crate) pattern_match_sequence:
        ruff_index::IndexVec<PatternMatchSequenceId, crate::PatternMatchSequence>,
    pub(crate) pattern_match_mapping:
        ruff_index::IndexVec<PatternMatchMappingId, crate::PatternMatchMapping>,
    pub(crate) pattern_match_class:
        ruff_index::IndexVec<PatternMatchClassId, crate::PatternMatchClass>,
    pub(crate) pattern_match_star:
        ruff_index::IndexVec<PatternMatchStarId, crate::PatternMatchStar>,
    pub(crate) pattern_match_as: ruff_index::IndexVec<PatternMatchAsId, crate::PatternMatchAs>,
    pub(crate) pattern_match_or: ruff_index::IndexVec<PatternMatchOrId, crate::PatternMatchOr>,
    pub(crate) type_param_type_var:
        ruff_index::IndexVec<TypeParamTypeVarId, crate::TypeParamTypeVar>,
    pub(crate) type_param_type_var_tuple:
        ruff_index::IndexVec<TypeParamTypeVarTupleId, crate::TypeParamTypeVarTuple>,
    pub(crate) type_param_param_spec:
        ruff_index::IndexVec<TypeParamParamSpecId, crate::TypeParamParamSpec>,
    pub(crate) f_string_format_spec:
        ruff_index::IndexVec<FStringFormatSpecId, crate::FStringFormatSpec>,
    pub(crate) pattern_arguments: ruff_index::IndexVec<PatternArgumentsId, crate::PatternArguments>,
    pub(crate) pattern_keyword: ruff_index::IndexVec<PatternKeywordId, crate::PatternKeyword>,
    pub(crate) comprehension: ruff_index::IndexVec<ComprehensionId, crate::Comprehension>,
    pub(crate) arguments: ruff_index::IndexVec<ArgumentsId, crate::Arguments>,
    pub(crate) parameters: ruff_index::IndexVec<ParametersId, crate::Parameters>,
    pub(crate) parameter: ruff_index::IndexVec<ParameterId, crate::Parameter>,
    pub(crate) parameter_with_default:
        ruff_index::IndexVec<ParameterWithDefaultId, crate::ParameterWithDefault>,
    pub(crate) keyword: ruff_index::IndexVec<KeywordId, crate::Keyword>,
    pub(crate) alias: ruff_index::IndexVec<AliasId, crate::Alias>,
    pub(crate) with_item: ruff_index::IndexVec<WithItemId, crate::WithItem>,
    pub(crate) match_case: ruff_index::IndexVec<MatchCaseId, crate::MatchCase>,
    pub(crate) decorator: ruff_index::IndexVec<DecoratorId, crate::Decorator>,
    pub(crate) elif_else_clause: ruff_index::IndexVec<ElifElseClauseId, crate::ElifElseClause>,
    pub(crate) type_params: ruff_index::IndexVec<TypeParamsId, crate::TypeParams>,
    pub(crate) f_string: ruff_index::IndexVec<FStringId, crate::FString>,
    pub(crate) string_literal: ruff_index::IndexVec<StringLiteralId, crate::StringLiteral>,
    pub(crate) bytes_literal: ruff_index::IndexVec<BytesLiteralId, crate::BytesLiteral>,
    pub(crate) identifier: ruff_index::IndexVec<IdentifierId, crate::Identifier>,
}

impl crate::ast::AstId for ModModuleId {
    type Output<'a> = crate::Node<'a, &'a crate::ModModule>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.mod_module[self])
    }
}

impl crate::ast::AstIdMut for ModModuleId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ModModule>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.mod_module[self])
    }
}

impl<'a> crate::Node<'a, ModModuleId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ModModule> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ModExpressionId {
    type Output<'a> = crate::Node<'a, &'a crate::ModExpression>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.mod_expression[self])
    }
}

impl crate::ast::AstIdMut for ModExpressionId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ModExpression>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.mod_expression[self])
    }
}

impl<'a> crate::Node<'a, ModExpressionId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ModExpression> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtFunctionDefId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtFunctionDef>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_function_def[self])
    }
}

impl crate::ast::AstIdMut for StmtFunctionDefId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtFunctionDef>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_function_def[self])
    }
}

impl<'a> crate::Node<'a, StmtFunctionDefId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtFunctionDef> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtClassDefId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtClassDef>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_class_def[self])
    }
}

impl crate::ast::AstIdMut for StmtClassDefId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtClassDef>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_class_def[self])
    }
}

impl<'a> crate::Node<'a, StmtClassDefId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtClassDef> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtReturnId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtReturn>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_return[self])
    }
}

impl crate::ast::AstIdMut for StmtReturnId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtReturn>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_return[self])
    }
}

impl<'a> crate::Node<'a, StmtReturnId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtReturn> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtDeleteId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtDelete>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_delete[self])
    }
}

impl crate::ast::AstIdMut for StmtDeleteId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtDelete>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_delete[self])
    }
}

impl<'a> crate::Node<'a, StmtDeleteId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtDelete> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtTypeAliasId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtTypeAlias>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_type_alias[self])
    }
}

impl crate::ast::AstIdMut for StmtTypeAliasId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtTypeAlias>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_type_alias[self])
    }
}

impl<'a> crate::Node<'a, StmtTypeAliasId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtTypeAlias> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtAssignId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtAssign>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_assign[self])
    }
}

impl crate::ast::AstIdMut for StmtAssignId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtAssign>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_assign[self])
    }
}

impl<'a> crate::Node<'a, StmtAssignId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtAssign> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtAugAssignId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtAugAssign>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_aug_assign[self])
    }
}

impl crate::ast::AstIdMut for StmtAugAssignId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtAugAssign>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_aug_assign[self])
    }
}

impl<'a> crate::Node<'a, StmtAugAssignId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtAugAssign> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtAnnAssignId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtAnnAssign>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_ann_assign[self])
    }
}

impl crate::ast::AstIdMut for StmtAnnAssignId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtAnnAssign>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_ann_assign[self])
    }
}

impl<'a> crate::Node<'a, StmtAnnAssignId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtAnnAssign> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtForId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtFor>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_for[self])
    }
}

impl crate::ast::AstIdMut for StmtForId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtFor>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_for[self])
    }
}

impl<'a> crate::Node<'a, StmtForId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtFor> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtWhileId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtWhile>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_while[self])
    }
}

impl crate::ast::AstIdMut for StmtWhileId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtWhile>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_while[self])
    }
}

impl<'a> crate::Node<'a, StmtWhileId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtWhile> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtIfId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtIf>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_if[self])
    }
}

impl crate::ast::AstIdMut for StmtIfId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtIf>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_if[self])
    }
}

impl<'a> crate::Node<'a, StmtIfId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtIf> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtWithId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtWith>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_with[self])
    }
}

impl crate::ast::AstIdMut for StmtWithId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtWith>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_with[self])
    }
}

impl<'a> crate::Node<'a, StmtWithId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtWith> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtMatchId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtMatch>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_match[self])
    }
}

impl crate::ast::AstIdMut for StmtMatchId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtMatch>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_match[self])
    }
}

impl<'a> crate::Node<'a, StmtMatchId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtMatch> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtRaiseId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtRaise>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_raise[self])
    }
}

impl crate::ast::AstIdMut for StmtRaiseId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtRaise>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_raise[self])
    }
}

impl<'a> crate::Node<'a, StmtRaiseId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtRaise> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtTryId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtTry>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_try[self])
    }
}

impl crate::ast::AstIdMut for StmtTryId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtTry>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_try[self])
    }
}

impl<'a> crate::Node<'a, StmtTryId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtTry> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtAssertId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtAssert>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_assert[self])
    }
}

impl crate::ast::AstIdMut for StmtAssertId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtAssert>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_assert[self])
    }
}

impl<'a> crate::Node<'a, StmtAssertId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtAssert> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtImportId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtImport>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_import[self])
    }
}

impl crate::ast::AstIdMut for StmtImportId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtImport>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_import[self])
    }
}

impl<'a> crate::Node<'a, StmtImportId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtImport> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtImportFromId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtImportFrom>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_import_from[self])
    }
}

impl crate::ast::AstIdMut for StmtImportFromId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtImportFrom>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_import_from[self])
    }
}

impl<'a> crate::Node<'a, StmtImportFromId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtImportFrom> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtGlobalId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtGlobal>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_global[self])
    }
}

impl crate::ast::AstIdMut for StmtGlobalId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtGlobal>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_global[self])
    }
}

impl<'a> crate::Node<'a, StmtGlobalId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtGlobal> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtNonlocalId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtNonlocal>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_nonlocal[self])
    }
}

impl crate::ast::AstIdMut for StmtNonlocalId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtNonlocal>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_nonlocal[self])
    }
}

impl<'a> crate::Node<'a, StmtNonlocalId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtNonlocal> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtExprId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtExpr>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_expr[self])
    }
}

impl crate::ast::AstIdMut for StmtExprId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtExpr>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_expr[self])
    }
}

impl<'a> crate::Node<'a, StmtExprId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtExpr> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtPassId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtPass>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_pass[self])
    }
}

impl crate::ast::AstIdMut for StmtPassId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtPass>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_pass[self])
    }
}

impl<'a> crate::Node<'a, StmtPassId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtPass> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtBreakId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtBreak>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_break[self])
    }
}

impl crate::ast::AstIdMut for StmtBreakId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtBreak>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_break[self])
    }
}

impl<'a> crate::Node<'a, StmtBreakId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtBreak> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtContinueId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtContinue>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_continue[self])
    }
}

impl crate::ast::AstIdMut for StmtContinueId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtContinue>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_continue[self])
    }
}

impl<'a> crate::Node<'a, StmtContinueId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtContinue> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtIpyEscapeCommandId {
    type Output<'a> = crate::Node<'a, &'a crate::StmtIpyEscapeCommand>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.stmt_ipy_escape_command[self])
    }
}

impl crate::ast::AstIdMut for StmtIpyEscapeCommandId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StmtIpyEscapeCommand>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.stmt_ipy_escape_command[self])
    }
}

impl<'a> crate::Node<'a, StmtIpyEscapeCommandId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtIpyEscapeCommand> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprBoolOpId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprBoolOp>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_bool_op[self])
    }
}

impl crate::ast::AstIdMut for ExprBoolOpId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprBoolOp>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_bool_op[self])
    }
}

impl<'a> crate::Node<'a, ExprBoolOpId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprBoolOp> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprNamedId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprNamed>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_named[self])
    }
}

impl crate::ast::AstIdMut for ExprNamedId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprNamed>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_named[self])
    }
}

impl<'a> crate::Node<'a, ExprNamedId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprNamed> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprBinOpId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprBinOp>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_bin_op[self])
    }
}

impl crate::ast::AstIdMut for ExprBinOpId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprBinOp>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_bin_op[self])
    }
}

impl<'a> crate::Node<'a, ExprBinOpId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprBinOp> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprUnaryOpId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprUnaryOp>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_unary_op[self])
    }
}

impl crate::ast::AstIdMut for ExprUnaryOpId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprUnaryOp>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_unary_op[self])
    }
}

impl<'a> crate::Node<'a, ExprUnaryOpId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprUnaryOp> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprLambdaId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprLambda>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_lambda[self])
    }
}

impl crate::ast::AstIdMut for ExprLambdaId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprLambda>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_lambda[self])
    }
}

impl<'a> crate::Node<'a, ExprLambdaId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprLambda> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprIfId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprIf>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_if[self])
    }
}

impl crate::ast::AstIdMut for ExprIfId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprIf>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_if[self])
    }
}

impl<'a> crate::Node<'a, ExprIfId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprIf> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprDictId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprDict>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_dict[self])
    }
}

impl crate::ast::AstIdMut for ExprDictId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprDict>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_dict[self])
    }
}

impl<'a> crate::Node<'a, ExprDictId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprDict> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprSetId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprSet>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_set[self])
    }
}

impl crate::ast::AstIdMut for ExprSetId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprSet>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_set[self])
    }
}

impl<'a> crate::Node<'a, ExprSetId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprSet> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprListCompId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprListComp>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_list_comp[self])
    }
}

impl crate::ast::AstIdMut for ExprListCompId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprListComp>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_list_comp[self])
    }
}

impl<'a> crate::Node<'a, ExprListCompId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprListComp> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprSetCompId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprSetComp>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_set_comp[self])
    }
}

impl crate::ast::AstIdMut for ExprSetCompId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprSetComp>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_set_comp[self])
    }
}

impl<'a> crate::Node<'a, ExprSetCompId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprSetComp> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprDictCompId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprDictComp>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_dict_comp[self])
    }
}

impl crate::ast::AstIdMut for ExprDictCompId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprDictComp>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_dict_comp[self])
    }
}

impl<'a> crate::Node<'a, ExprDictCompId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprDictComp> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprGeneratorId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprGenerator>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_generator[self])
    }
}

impl crate::ast::AstIdMut for ExprGeneratorId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprGenerator>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_generator[self])
    }
}

impl<'a> crate::Node<'a, ExprGeneratorId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprGenerator> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprAwaitId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprAwait>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_await[self])
    }
}

impl crate::ast::AstIdMut for ExprAwaitId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprAwait>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_await[self])
    }
}

impl<'a> crate::Node<'a, ExprAwaitId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprAwait> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprYieldId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprYield>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_yield[self])
    }
}

impl crate::ast::AstIdMut for ExprYieldId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprYield>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_yield[self])
    }
}

impl<'a> crate::Node<'a, ExprYieldId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprYield> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprYieldFromId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprYieldFrom>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_yield_from[self])
    }
}

impl crate::ast::AstIdMut for ExprYieldFromId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprYieldFrom>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_yield_from[self])
    }
}

impl<'a> crate::Node<'a, ExprYieldFromId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprYieldFrom> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprCompareId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprCompare>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_compare[self])
    }
}

impl crate::ast::AstIdMut for ExprCompareId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprCompare>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_compare[self])
    }
}

impl<'a> crate::Node<'a, ExprCompareId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprCompare> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprCallId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprCall>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_call[self])
    }
}

impl crate::ast::AstIdMut for ExprCallId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprCall>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_call[self])
    }
}

impl<'a> crate::Node<'a, ExprCallId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprCall> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprFStringId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprFString>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_f_string[self])
    }
}

impl crate::ast::AstIdMut for ExprFStringId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprFString>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_f_string[self])
    }
}

impl<'a> crate::Node<'a, ExprFStringId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprFString> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprStringLiteralId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprStringLiteral>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_string_literal[self])
    }
}

impl crate::ast::AstIdMut for ExprStringLiteralId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprStringLiteral>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_string_literal[self])
    }
}

impl<'a> crate::Node<'a, ExprStringLiteralId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprStringLiteral> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprBytesLiteralId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprBytesLiteral>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_bytes_literal[self])
    }
}

impl crate::ast::AstIdMut for ExprBytesLiteralId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprBytesLiteral>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_bytes_literal[self])
    }
}

impl<'a> crate::Node<'a, ExprBytesLiteralId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprBytesLiteral> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprNumberLiteralId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprNumberLiteral>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_number_literal[self])
    }
}

impl crate::ast::AstIdMut for ExprNumberLiteralId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprNumberLiteral>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_number_literal[self])
    }
}

impl<'a> crate::Node<'a, ExprNumberLiteralId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprNumberLiteral> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprBooleanLiteralId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprBooleanLiteral>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_boolean_literal[self])
    }
}

impl crate::ast::AstIdMut for ExprBooleanLiteralId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprBooleanLiteral>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_boolean_literal[self])
    }
}

impl<'a> crate::Node<'a, ExprBooleanLiteralId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprBooleanLiteral> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprNoneLiteralId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprNoneLiteral>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_none_literal[self])
    }
}

impl crate::ast::AstIdMut for ExprNoneLiteralId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprNoneLiteral>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_none_literal[self])
    }
}

impl<'a> crate::Node<'a, ExprNoneLiteralId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprNoneLiteral> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprEllipsisLiteralId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprEllipsisLiteral>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_ellipsis_literal[self])
    }
}

impl crate::ast::AstIdMut for ExprEllipsisLiteralId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprEllipsisLiteral>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_ellipsis_literal[self])
    }
}

impl<'a> crate::Node<'a, ExprEllipsisLiteralId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprEllipsisLiteral> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprAttributeId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprAttribute>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_attribute[self])
    }
}

impl crate::ast::AstIdMut for ExprAttributeId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprAttribute>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_attribute[self])
    }
}

impl<'a> crate::Node<'a, ExprAttributeId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprAttribute> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprSubscriptId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprSubscript>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_subscript[self])
    }
}

impl crate::ast::AstIdMut for ExprSubscriptId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprSubscript>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_subscript[self])
    }
}

impl<'a> crate::Node<'a, ExprSubscriptId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprSubscript> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprStarredId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprStarred>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_starred[self])
    }
}

impl crate::ast::AstIdMut for ExprStarredId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprStarred>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_starred[self])
    }
}

impl<'a> crate::Node<'a, ExprStarredId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprStarred> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprNameId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprName>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_name[self])
    }
}

impl crate::ast::AstIdMut for ExprNameId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprName>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_name[self])
    }
}

impl<'a> crate::Node<'a, ExprNameId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprName> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprListId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprList>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_list[self])
    }
}

impl crate::ast::AstIdMut for ExprListId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprList>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_list[self])
    }
}

impl<'a> crate::Node<'a, ExprListId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprList> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprTupleId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprTuple>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_tuple[self])
    }
}

impl crate::ast::AstIdMut for ExprTupleId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprTuple>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_tuple[self])
    }
}

impl<'a> crate::Node<'a, ExprTupleId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprTuple> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprSliceId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprSlice>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_slice[self])
    }
}

impl crate::ast::AstIdMut for ExprSliceId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprSlice>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_slice[self])
    }
}

impl<'a> crate::Node<'a, ExprSliceId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprSlice> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprIpyEscapeCommandId {
    type Output<'a> = crate::Node<'a, &'a crate::ExprIpyEscapeCommand>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.expr_ipy_escape_command[self])
    }
}

impl crate::ast::AstIdMut for ExprIpyEscapeCommandId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExprIpyEscapeCommand>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.expr_ipy_escape_command[self])
    }
}

impl<'a> crate::Node<'a, ExprIpyEscapeCommandId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprIpyEscapeCommand> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExceptHandlerExceptHandlerId {
    type Output<'a> = crate::Node<'a, &'a crate::ExceptHandlerExceptHandler>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.except_handler_except_handler[self])
    }
}

impl crate::ast::AstIdMut for ExceptHandlerExceptHandlerId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ExceptHandlerExceptHandler>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.except_handler_except_handler[self])
    }
}

impl<'a> crate::Node<'a, ExceptHandlerExceptHandlerId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExceptHandlerExceptHandler> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for FStringExpressionElementId {
    type Output<'a> = crate::Node<'a, &'a crate::FStringExpressionElement>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.f_string_expression_element[self])
    }
}

impl crate::ast::AstIdMut for FStringExpressionElementId {
    type Output<'a> = crate::Node<'a, &'a mut crate::FStringExpressionElement>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.f_string_expression_element[self])
    }
}

impl<'a> crate::Node<'a, FStringExpressionElementId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::FStringExpressionElement> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for FStringLiteralElementId {
    type Output<'a> = crate::Node<'a, &'a crate::FStringLiteralElement>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.f_string_literal_element[self])
    }
}

impl crate::ast::AstIdMut for FStringLiteralElementId {
    type Output<'a> = crate::Node<'a, &'a mut crate::FStringLiteralElement>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.f_string_literal_element[self])
    }
}

impl<'a> crate::Node<'a, FStringLiteralElementId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::FStringLiteralElement> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for PatternMatchValueId {
    type Output<'a> = crate::Node<'a, &'a crate::PatternMatchValue>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.pattern_match_value[self])
    }
}

impl crate::ast::AstIdMut for PatternMatchValueId {
    type Output<'a> = crate::Node<'a, &'a mut crate::PatternMatchValue>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.pattern_match_value[self])
    }
}

impl<'a> crate::Node<'a, PatternMatchValueId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::PatternMatchValue> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for PatternMatchSingletonId {
    type Output<'a> = crate::Node<'a, &'a crate::PatternMatchSingleton>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.pattern_match_singleton[self])
    }
}

impl crate::ast::AstIdMut for PatternMatchSingletonId {
    type Output<'a> = crate::Node<'a, &'a mut crate::PatternMatchSingleton>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.pattern_match_singleton[self])
    }
}

impl<'a> crate::Node<'a, PatternMatchSingletonId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::PatternMatchSingleton> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for PatternMatchSequenceId {
    type Output<'a> = crate::Node<'a, &'a crate::PatternMatchSequence>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.pattern_match_sequence[self])
    }
}

impl crate::ast::AstIdMut for PatternMatchSequenceId {
    type Output<'a> = crate::Node<'a, &'a mut crate::PatternMatchSequence>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.pattern_match_sequence[self])
    }
}

impl<'a> crate::Node<'a, PatternMatchSequenceId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::PatternMatchSequence> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for PatternMatchMappingId {
    type Output<'a> = crate::Node<'a, &'a crate::PatternMatchMapping>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.pattern_match_mapping[self])
    }
}

impl crate::ast::AstIdMut for PatternMatchMappingId {
    type Output<'a> = crate::Node<'a, &'a mut crate::PatternMatchMapping>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.pattern_match_mapping[self])
    }
}

impl<'a> crate::Node<'a, PatternMatchMappingId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::PatternMatchMapping> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for PatternMatchClassId {
    type Output<'a> = crate::Node<'a, &'a crate::PatternMatchClass>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.pattern_match_class[self])
    }
}

impl crate::ast::AstIdMut for PatternMatchClassId {
    type Output<'a> = crate::Node<'a, &'a mut crate::PatternMatchClass>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.pattern_match_class[self])
    }
}

impl<'a> crate::Node<'a, PatternMatchClassId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::PatternMatchClass> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for PatternMatchStarId {
    type Output<'a> = crate::Node<'a, &'a crate::PatternMatchStar>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.pattern_match_star[self])
    }
}

impl crate::ast::AstIdMut for PatternMatchStarId {
    type Output<'a> = crate::Node<'a, &'a mut crate::PatternMatchStar>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.pattern_match_star[self])
    }
}

impl<'a> crate::Node<'a, PatternMatchStarId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::PatternMatchStar> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for PatternMatchAsId {
    type Output<'a> = crate::Node<'a, &'a crate::PatternMatchAs>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.pattern_match_as[self])
    }
}

impl crate::ast::AstIdMut for PatternMatchAsId {
    type Output<'a> = crate::Node<'a, &'a mut crate::PatternMatchAs>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.pattern_match_as[self])
    }
}

impl<'a> crate::Node<'a, PatternMatchAsId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::PatternMatchAs> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for PatternMatchOrId {
    type Output<'a> = crate::Node<'a, &'a crate::PatternMatchOr>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.pattern_match_or[self])
    }
}

impl crate::ast::AstIdMut for PatternMatchOrId {
    type Output<'a> = crate::Node<'a, &'a mut crate::PatternMatchOr>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.pattern_match_or[self])
    }
}

impl<'a> crate::Node<'a, PatternMatchOrId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::PatternMatchOr> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for TypeParamTypeVarId {
    type Output<'a> = crate::Node<'a, &'a crate::TypeParamTypeVar>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.type_param_type_var[self])
    }
}

impl crate::ast::AstIdMut for TypeParamTypeVarId {
    type Output<'a> = crate::Node<'a, &'a mut crate::TypeParamTypeVar>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.type_param_type_var[self])
    }
}

impl<'a> crate::Node<'a, TypeParamTypeVarId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::TypeParamTypeVar> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for TypeParamTypeVarTupleId {
    type Output<'a> = crate::Node<'a, &'a crate::TypeParamTypeVarTuple>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.type_param_type_var_tuple[self])
    }
}

impl crate::ast::AstIdMut for TypeParamTypeVarTupleId {
    type Output<'a> = crate::Node<'a, &'a mut crate::TypeParamTypeVarTuple>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.type_param_type_var_tuple[self])
    }
}

impl<'a> crate::Node<'a, TypeParamTypeVarTupleId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::TypeParamTypeVarTuple> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for TypeParamParamSpecId {
    type Output<'a> = crate::Node<'a, &'a crate::TypeParamParamSpec>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.type_param_param_spec[self])
    }
}

impl crate::ast::AstIdMut for TypeParamParamSpecId {
    type Output<'a> = crate::Node<'a, &'a mut crate::TypeParamParamSpec>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.type_param_param_spec[self])
    }
}

impl<'a> crate::Node<'a, TypeParamParamSpecId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::TypeParamParamSpec> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for FStringFormatSpecId {
    type Output<'a> = crate::Node<'a, &'a crate::FStringFormatSpec>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.f_string_format_spec[self])
    }
}

impl crate::ast::AstIdMut for FStringFormatSpecId {
    type Output<'a> = crate::Node<'a, &'a mut crate::FStringFormatSpec>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.f_string_format_spec[self])
    }
}

impl<'a> crate::Node<'a, FStringFormatSpecId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::FStringFormatSpec> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for PatternArgumentsId {
    type Output<'a> = crate::Node<'a, &'a crate::PatternArguments>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.pattern_arguments[self])
    }
}

impl crate::ast::AstIdMut for PatternArgumentsId {
    type Output<'a> = crate::Node<'a, &'a mut crate::PatternArguments>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.pattern_arguments[self])
    }
}

impl<'a> crate::Node<'a, PatternArgumentsId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::PatternArguments> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for PatternKeywordId {
    type Output<'a> = crate::Node<'a, &'a crate::PatternKeyword>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.pattern_keyword[self])
    }
}

impl crate::ast::AstIdMut for PatternKeywordId {
    type Output<'a> = crate::Node<'a, &'a mut crate::PatternKeyword>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.pattern_keyword[self])
    }
}

impl<'a> crate::Node<'a, PatternKeywordId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::PatternKeyword> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ComprehensionId {
    type Output<'a> = crate::Node<'a, &'a crate::Comprehension>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.comprehension[self])
    }
}

impl crate::ast::AstIdMut for ComprehensionId {
    type Output<'a> = crate::Node<'a, &'a mut crate::Comprehension>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.comprehension[self])
    }
}

impl<'a> crate::Node<'a, ComprehensionId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::Comprehension> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ArgumentsId {
    type Output<'a> = crate::Node<'a, &'a crate::Arguments>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.arguments[self])
    }
}

impl crate::ast::AstIdMut for ArgumentsId {
    type Output<'a> = crate::Node<'a, &'a mut crate::Arguments>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.arguments[self])
    }
}

impl<'a> crate::Node<'a, ArgumentsId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::Arguments> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ParametersId {
    type Output<'a> = crate::Node<'a, &'a crate::Parameters>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.parameters[self])
    }
}

impl crate::ast::AstIdMut for ParametersId {
    type Output<'a> = crate::Node<'a, &'a mut crate::Parameters>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.parameters[self])
    }
}

impl<'a> crate::Node<'a, ParametersId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::Parameters> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ParameterId {
    type Output<'a> = crate::Node<'a, &'a crate::Parameter>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.parameter[self])
    }
}

impl crate::ast::AstIdMut for ParameterId {
    type Output<'a> = crate::Node<'a, &'a mut crate::Parameter>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.parameter[self])
    }
}

impl<'a> crate::Node<'a, ParameterId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::Parameter> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ParameterWithDefaultId {
    type Output<'a> = crate::Node<'a, &'a crate::ParameterWithDefault>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.parameter_with_default[self])
    }
}

impl crate::ast::AstIdMut for ParameterWithDefaultId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ParameterWithDefault>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.parameter_with_default[self])
    }
}

impl<'a> crate::Node<'a, ParameterWithDefaultId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ParameterWithDefault> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for KeywordId {
    type Output<'a> = crate::Node<'a, &'a crate::Keyword>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.keyword[self])
    }
}

impl crate::ast::AstIdMut for KeywordId {
    type Output<'a> = crate::Node<'a, &'a mut crate::Keyword>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.keyword[self])
    }
}

impl<'a> crate::Node<'a, KeywordId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::Keyword> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for AliasId {
    type Output<'a> = crate::Node<'a, &'a crate::Alias>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.alias[self])
    }
}

impl crate::ast::AstIdMut for AliasId {
    type Output<'a> = crate::Node<'a, &'a mut crate::Alias>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.alias[self])
    }
}

impl<'a> crate::Node<'a, AliasId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::Alias> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for WithItemId {
    type Output<'a> = crate::Node<'a, &'a crate::WithItem>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.with_item[self])
    }
}

impl crate::ast::AstIdMut for WithItemId {
    type Output<'a> = crate::Node<'a, &'a mut crate::WithItem>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.with_item[self])
    }
}

impl<'a> crate::Node<'a, WithItemId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::WithItem> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for MatchCaseId {
    type Output<'a> = crate::Node<'a, &'a crate::MatchCase>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.match_case[self])
    }
}

impl crate::ast::AstIdMut for MatchCaseId {
    type Output<'a> = crate::Node<'a, &'a mut crate::MatchCase>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.match_case[self])
    }
}

impl<'a> crate::Node<'a, MatchCaseId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::MatchCase> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for DecoratorId {
    type Output<'a> = crate::Node<'a, &'a crate::Decorator>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.decorator[self])
    }
}

impl crate::ast::AstIdMut for DecoratorId {
    type Output<'a> = crate::Node<'a, &'a mut crate::Decorator>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.decorator[self])
    }
}

impl<'a> crate::Node<'a, DecoratorId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::Decorator> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ElifElseClauseId {
    type Output<'a> = crate::Node<'a, &'a crate::ElifElseClause>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.elif_else_clause[self])
    }
}

impl crate::ast::AstIdMut for ElifElseClauseId {
    type Output<'a> = crate::Node<'a, &'a mut crate::ElifElseClause>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.elif_else_clause[self])
    }
}

impl<'a> crate::Node<'a, ElifElseClauseId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ElifElseClause> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for TypeParamsId {
    type Output<'a> = crate::Node<'a, &'a crate::TypeParams>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.type_params[self])
    }
}

impl crate::ast::AstIdMut for TypeParamsId {
    type Output<'a> = crate::Node<'a, &'a mut crate::TypeParams>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.type_params[self])
    }
}

impl<'a> crate::Node<'a, TypeParamsId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::TypeParams> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for FStringId {
    type Output<'a> = crate::Node<'a, &'a crate::FString>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.f_string[self])
    }
}

impl crate::ast::AstIdMut for FStringId {
    type Output<'a> = crate::Node<'a, &'a mut crate::FString>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.f_string[self])
    }
}

impl<'a> crate::Node<'a, FStringId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::FString> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StringLiteralId {
    type Output<'a> = crate::Node<'a, &'a crate::StringLiteral>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.string_literal[self])
    }
}

impl crate::ast::AstIdMut for StringLiteralId {
    type Output<'a> = crate::Node<'a, &'a mut crate::StringLiteral>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.string_literal[self])
    }
}

impl<'a> crate::Node<'a, StringLiteralId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StringLiteral> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for BytesLiteralId {
    type Output<'a> = crate::Node<'a, &'a crate::BytesLiteral>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.bytes_literal[self])
    }
}

impl crate::ast::AstIdMut for BytesLiteralId {
    type Output<'a> = crate::Node<'a, &'a mut crate::BytesLiteral>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.bytes_literal[self])
    }
}

impl<'a> crate::Node<'a, BytesLiteralId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::BytesLiteral> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for IdentifierId {
    type Output<'a> = crate::Node<'a, &'a crate::Identifier>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        ast.wrap(&ast.storage.identifier[self])
    }
}

impl crate::ast::AstIdMut for IdentifierId {
    type Output<'a> = crate::Node<'a, &'a mut crate::Identifier>;
    #[inline]
    fn node_mut<'a>(self, ast: &'a mut crate::Ast) -> Self::Output<'a> {
        ast.wrap(&mut ast.storage.identifier[self])
    }
}

impl<'a> crate::Node<'a, IdentifierId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::Identifier> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ModId {
    type Output<'a> = ModRef<'a>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        match self {
            ModId::Module(node) => ModRef::Module(ast.node(node)),
            ModId::Expression(node) => ModRef::Expression(ast.node(node)),
        }
    }
}

impl<'a> crate::Node<'a, ModId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ModExpression> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for StmtId {
    type Output<'a> = StmtRef<'a>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        match self {
            StmtId::FunctionDef(node) => StmtRef::FunctionDef(ast.node(node)),
            StmtId::ClassDef(node) => StmtRef::ClassDef(ast.node(node)),
            StmtId::Return(node) => StmtRef::Return(ast.node(node)),
            StmtId::Delete(node) => StmtRef::Delete(ast.node(node)),
            StmtId::TypeAlias(node) => StmtRef::TypeAlias(ast.node(node)),
            StmtId::Assign(node) => StmtRef::Assign(ast.node(node)),
            StmtId::AugAssign(node) => StmtRef::AugAssign(ast.node(node)),
            StmtId::AnnAssign(node) => StmtRef::AnnAssign(ast.node(node)),
            StmtId::For(node) => StmtRef::For(ast.node(node)),
            StmtId::While(node) => StmtRef::While(ast.node(node)),
            StmtId::If(node) => StmtRef::If(ast.node(node)),
            StmtId::With(node) => StmtRef::With(ast.node(node)),
            StmtId::Match(node) => StmtRef::Match(ast.node(node)),
            StmtId::Raise(node) => StmtRef::Raise(ast.node(node)),
            StmtId::Try(node) => StmtRef::Try(ast.node(node)),
            StmtId::Assert(node) => StmtRef::Assert(ast.node(node)),
            StmtId::Import(node) => StmtRef::Import(ast.node(node)),
            StmtId::ImportFrom(node) => StmtRef::ImportFrom(ast.node(node)),
            StmtId::Global(node) => StmtRef::Global(ast.node(node)),
            StmtId::Nonlocal(node) => StmtRef::Nonlocal(ast.node(node)),
            StmtId::Expr(node) => StmtRef::Expr(ast.node(node)),
            StmtId::Pass(node) => StmtRef::Pass(ast.node(node)),
            StmtId::Break(node) => StmtRef::Break(ast.node(node)),
            StmtId::Continue(node) => StmtRef::Continue(ast.node(node)),
            StmtId::IpyEscapeCommand(node) => StmtRef::IpyEscapeCommand(ast.node(node)),
        }
    }
}

impl<'a> crate::Node<'a, StmtId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::StmtIpyEscapeCommand> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExprId {
    type Output<'a> = ExprRef<'a>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        match self {
            ExprId::BoolOp(node) => ExprRef::BoolOp(ast.node(node)),
            ExprId::Named(node) => ExprRef::Named(ast.node(node)),
            ExprId::BinOp(node) => ExprRef::BinOp(ast.node(node)),
            ExprId::UnaryOp(node) => ExprRef::UnaryOp(ast.node(node)),
            ExprId::Lambda(node) => ExprRef::Lambda(ast.node(node)),
            ExprId::If(node) => ExprRef::If(ast.node(node)),
            ExprId::Dict(node) => ExprRef::Dict(ast.node(node)),
            ExprId::Set(node) => ExprRef::Set(ast.node(node)),
            ExprId::ListComp(node) => ExprRef::ListComp(ast.node(node)),
            ExprId::SetComp(node) => ExprRef::SetComp(ast.node(node)),
            ExprId::DictComp(node) => ExprRef::DictComp(ast.node(node)),
            ExprId::Generator(node) => ExprRef::Generator(ast.node(node)),
            ExprId::Await(node) => ExprRef::Await(ast.node(node)),
            ExprId::Yield(node) => ExprRef::Yield(ast.node(node)),
            ExprId::YieldFrom(node) => ExprRef::YieldFrom(ast.node(node)),
            ExprId::Compare(node) => ExprRef::Compare(ast.node(node)),
            ExprId::Call(node) => ExprRef::Call(ast.node(node)),
            ExprId::FString(node) => ExprRef::FString(ast.node(node)),
            ExprId::StringLiteral(node) => ExprRef::StringLiteral(ast.node(node)),
            ExprId::BytesLiteral(node) => ExprRef::BytesLiteral(ast.node(node)),
            ExprId::NumberLiteral(node) => ExprRef::NumberLiteral(ast.node(node)),
            ExprId::BooleanLiteral(node) => ExprRef::BooleanLiteral(ast.node(node)),
            ExprId::NoneLiteral(node) => ExprRef::NoneLiteral(ast.node(node)),
            ExprId::EllipsisLiteral(node) => ExprRef::EllipsisLiteral(ast.node(node)),
            ExprId::Attribute(node) => ExprRef::Attribute(ast.node(node)),
            ExprId::Subscript(node) => ExprRef::Subscript(ast.node(node)),
            ExprId::Starred(node) => ExprRef::Starred(ast.node(node)),
            ExprId::Name(node) => ExprRef::Name(ast.node(node)),
            ExprId::List(node) => ExprRef::List(ast.node(node)),
            ExprId::Tuple(node) => ExprRef::Tuple(ast.node(node)),
            ExprId::Slice(node) => ExprRef::Slice(ast.node(node)),
            ExprId::IpyEscapeCommand(node) => ExprRef::IpyEscapeCommand(ast.node(node)),
        }
    }
}

impl<'a> crate::Node<'a, ExprId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExprIpyEscapeCommand> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for ExceptHandlerId {
    type Output<'a> = ExceptHandlerRef<'a>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        match self {
            ExceptHandlerId::ExceptHandler(node) => ExceptHandlerRef::ExceptHandler(ast.node(node)),
        }
    }
}

impl<'a> crate::Node<'a, ExceptHandlerId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::ExceptHandlerExceptHandler> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for FStringElementId {
    type Output<'a> = FStringElementRef<'a>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        match self {
            FStringElementId::Expression(node) => FStringElementRef::Expression(ast.node(node)),
            FStringElementId::Literal(node) => FStringElementRef::Literal(ast.node(node)),
        }
    }
}

impl<'a> crate::Node<'a, FStringElementId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::FStringLiteralElement> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for PatternId {
    type Output<'a> = PatternRef<'a>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        match self {
            PatternId::MatchValue(node) => PatternRef::MatchValue(ast.node(node)),
            PatternId::MatchSingleton(node) => PatternRef::MatchSingleton(ast.node(node)),
            PatternId::MatchSequence(node) => PatternRef::MatchSequence(ast.node(node)),
            PatternId::MatchMapping(node) => PatternRef::MatchMapping(ast.node(node)),
            PatternId::MatchClass(node) => PatternRef::MatchClass(ast.node(node)),
            PatternId::MatchStar(node) => PatternRef::MatchStar(ast.node(node)),
            PatternId::MatchAs(node) => PatternRef::MatchAs(ast.node(node)),
            PatternId::MatchOr(node) => PatternRef::MatchOr(ast.node(node)),
        }
    }
}

impl<'a> crate::Node<'a, PatternId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::PatternMatchOr> {
        self.ast.node(self.node)
    }
}

impl crate::ast::AstId for TypeParamId {
    type Output<'a> = TypeParamRef<'a>;
    #[inline]
    fn node<'a>(self, ast: &'a crate::Ast) -> Self::Output<'a> {
        match self {
            TypeParamId::TypeVar(node) => TypeParamRef::TypeVar(ast.node(node)),
            TypeParamId::TypeVarTuple(node) => TypeParamRef::TypeVarTuple(ast.node(node)),
            TypeParamId::ParamSpec(node) => TypeParamRef::ParamSpec(ast.node(node)),
        }
    }
}

impl<'a> crate::Node<'a, TypeParamId> {
    #[inline]
    pub fn node(self) -> crate::Node<'a, &'a crate::TypeParamParamSpec> {
        self.ast.node(self.node)
    }
}

#[derive(Copy, Clone, Debug, is_macro::Is, PartialEq)]
pub enum AnyNodeRef<'a> {
    ModModule(crate::Node<'a, &'a crate::ModModule>),
    ModExpression(crate::Node<'a, &'a crate::ModExpression>),
    StmtFunctionDef(crate::Node<'a, &'a crate::StmtFunctionDef>),
    StmtClassDef(crate::Node<'a, &'a crate::StmtClassDef>),
    StmtReturn(crate::Node<'a, &'a crate::StmtReturn>),
    StmtDelete(crate::Node<'a, &'a crate::StmtDelete>),
    StmtTypeAlias(crate::Node<'a, &'a crate::StmtTypeAlias>),
    StmtAssign(crate::Node<'a, &'a crate::StmtAssign>),
    StmtAugAssign(crate::Node<'a, &'a crate::StmtAugAssign>),
    StmtAnnAssign(crate::Node<'a, &'a crate::StmtAnnAssign>),
    StmtFor(crate::Node<'a, &'a crate::StmtFor>),
    StmtWhile(crate::Node<'a, &'a crate::StmtWhile>),
    StmtIf(crate::Node<'a, &'a crate::StmtIf>),
    StmtWith(crate::Node<'a, &'a crate::StmtWith>),
    StmtMatch(crate::Node<'a, &'a crate::StmtMatch>),
    StmtRaise(crate::Node<'a, &'a crate::StmtRaise>),
    StmtTry(crate::Node<'a, &'a crate::StmtTry>),
    StmtAssert(crate::Node<'a, &'a crate::StmtAssert>),
    StmtImport(crate::Node<'a, &'a crate::StmtImport>),
    StmtImportFrom(crate::Node<'a, &'a crate::StmtImportFrom>),
    StmtGlobal(crate::Node<'a, &'a crate::StmtGlobal>),
    StmtNonlocal(crate::Node<'a, &'a crate::StmtNonlocal>),
    StmtExpr(crate::Node<'a, &'a crate::StmtExpr>),
    StmtPass(crate::Node<'a, &'a crate::StmtPass>),
    StmtBreak(crate::Node<'a, &'a crate::StmtBreak>),
    StmtContinue(crate::Node<'a, &'a crate::StmtContinue>),
    StmtIpyEscapeCommand(crate::Node<'a, &'a crate::StmtIpyEscapeCommand>),
    ExprBoolOp(crate::Node<'a, &'a crate::ExprBoolOp>),
    ExprNamed(crate::Node<'a, &'a crate::ExprNamed>),
    ExprBinOp(crate::Node<'a, &'a crate::ExprBinOp>),
    ExprUnaryOp(crate::Node<'a, &'a crate::ExprUnaryOp>),
    ExprLambda(crate::Node<'a, &'a crate::ExprLambda>),
    ExprIf(crate::Node<'a, &'a crate::ExprIf>),
    ExprDict(crate::Node<'a, &'a crate::ExprDict>),
    ExprSet(crate::Node<'a, &'a crate::ExprSet>),
    ExprListComp(crate::Node<'a, &'a crate::ExprListComp>),
    ExprSetComp(crate::Node<'a, &'a crate::ExprSetComp>),
    ExprDictComp(crate::Node<'a, &'a crate::ExprDictComp>),
    ExprGenerator(crate::Node<'a, &'a crate::ExprGenerator>),
    ExprAwait(crate::Node<'a, &'a crate::ExprAwait>),
    ExprYield(crate::Node<'a, &'a crate::ExprYield>),
    ExprYieldFrom(crate::Node<'a, &'a crate::ExprYieldFrom>),
    ExprCompare(crate::Node<'a, &'a crate::ExprCompare>),
    ExprCall(crate::Node<'a, &'a crate::ExprCall>),
    ExprFString(crate::Node<'a, &'a crate::ExprFString>),
    ExprStringLiteral(crate::Node<'a, &'a crate::ExprStringLiteral>),
    ExprBytesLiteral(crate::Node<'a, &'a crate::ExprBytesLiteral>),
    ExprNumberLiteral(crate::Node<'a, &'a crate::ExprNumberLiteral>),
    ExprBooleanLiteral(crate::Node<'a, &'a crate::ExprBooleanLiteral>),
    ExprNoneLiteral(crate::Node<'a, &'a crate::ExprNoneLiteral>),
    ExprEllipsisLiteral(crate::Node<'a, &'a crate::ExprEllipsisLiteral>),
    ExprAttribute(crate::Node<'a, &'a crate::ExprAttribute>),
    ExprSubscript(crate::Node<'a, &'a crate::ExprSubscript>),
    ExprStarred(crate::Node<'a, &'a crate::ExprStarred>),
    ExprName(crate::Node<'a, &'a crate::ExprName>),
    ExprList(crate::Node<'a, &'a crate::ExprList>),
    ExprTuple(crate::Node<'a, &'a crate::ExprTuple>),
    ExprSlice(crate::Node<'a, &'a crate::ExprSlice>),
    ExprIpyEscapeCommand(crate::Node<'a, &'a crate::ExprIpyEscapeCommand>),
    ExceptHandlerExceptHandler(crate::Node<'a, &'a crate::ExceptHandlerExceptHandler>),
    FStringExpressionElement(crate::Node<'a, &'a crate::FStringExpressionElement>),
    FStringLiteralElement(crate::Node<'a, &'a crate::FStringLiteralElement>),
    PatternMatchValue(crate::Node<'a, &'a crate::PatternMatchValue>),
    PatternMatchSingleton(crate::Node<'a, &'a crate::PatternMatchSingleton>),
    PatternMatchSequence(crate::Node<'a, &'a crate::PatternMatchSequence>),
    PatternMatchMapping(crate::Node<'a, &'a crate::PatternMatchMapping>),
    PatternMatchClass(crate::Node<'a, &'a crate::PatternMatchClass>),
    PatternMatchStar(crate::Node<'a, &'a crate::PatternMatchStar>),
    PatternMatchAs(crate::Node<'a, &'a crate::PatternMatchAs>),
    PatternMatchOr(crate::Node<'a, &'a crate::PatternMatchOr>),
    TypeParamTypeVar(crate::Node<'a, &'a crate::TypeParamTypeVar>),
    TypeParamTypeVarTuple(crate::Node<'a, &'a crate::TypeParamTypeVarTuple>),
    TypeParamParamSpec(crate::Node<'a, &'a crate::TypeParamParamSpec>),
    FStringFormatSpec(crate::Node<'a, &'a crate::FStringFormatSpec>),
    PatternArguments(crate::Node<'a, &'a crate::PatternArguments>),
    PatternKeyword(crate::Node<'a, &'a crate::PatternKeyword>),
    Comprehension(crate::Node<'a, &'a crate::Comprehension>),
    Arguments(crate::Node<'a, &'a crate::Arguments>),
    Parameters(crate::Node<'a, &'a crate::Parameters>),
    Parameter(crate::Node<'a, &'a crate::Parameter>),
    ParameterWithDefault(crate::Node<'a, &'a crate::ParameterWithDefault>),
    Keyword(crate::Node<'a, &'a crate::Keyword>),
    Alias(crate::Node<'a, &'a crate::Alias>),
    WithItem(crate::Node<'a, &'a crate::WithItem>),
    MatchCase(crate::Node<'a, &'a crate::MatchCase>),
    Decorator(crate::Node<'a, &'a crate::Decorator>),
    ElifElseClause(crate::Node<'a, &'a crate::ElifElseClause>),
    TypeParams(crate::Node<'a, &'a crate::TypeParams>),
    FString(crate::Node<'a, &'a crate::FString>),
    StringLiteral(crate::Node<'a, &'a crate::StringLiteral>),
    BytesLiteral(crate::Node<'a, &'a crate::BytesLiteral>),
    Identifier(crate::Node<'a, &'a crate::Identifier>),
}

impl<'a> From<crate::Node<'a, &'a Mod>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a Mod>) -> AnyNodeRef<'a> {
        match node.node {
            Mod::Module(n) => AnyNodeRef::ModModule(node.ast.wrap(n)),
            Mod::Expression(n) => AnyNodeRef::ModExpression(node.ast.wrap(n)),
        }
    }
}

impl<'a> From<ModRef<'a>> for AnyNodeRef<'a> {
    fn from(node: ModRef<'a>) -> AnyNodeRef<'a> {
        match node {
            ModRef::Module(node) => AnyNodeRef::ModModule(node),
            ModRef::Expression(node) => AnyNodeRef::ModExpression(node),
        }
    }
}

impl<'a> From<crate::Node<'a, &'a Stmt>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a Stmt>) -> AnyNodeRef<'a> {
        match node.node {
            Stmt::FunctionDef(n) => AnyNodeRef::StmtFunctionDef(node.ast.wrap(n)),
            Stmt::ClassDef(n) => AnyNodeRef::StmtClassDef(node.ast.wrap(n)),
            Stmt::Return(n) => AnyNodeRef::StmtReturn(node.ast.wrap(n)),
            Stmt::Delete(n) => AnyNodeRef::StmtDelete(node.ast.wrap(n)),
            Stmt::TypeAlias(n) => AnyNodeRef::StmtTypeAlias(node.ast.wrap(n)),
            Stmt::Assign(n) => AnyNodeRef::StmtAssign(node.ast.wrap(n)),
            Stmt::AugAssign(n) => AnyNodeRef::StmtAugAssign(node.ast.wrap(n)),
            Stmt::AnnAssign(n) => AnyNodeRef::StmtAnnAssign(node.ast.wrap(n)),
            Stmt::For(n) => AnyNodeRef::StmtFor(node.ast.wrap(n)),
            Stmt::While(n) => AnyNodeRef::StmtWhile(node.ast.wrap(n)),
            Stmt::If(n) => AnyNodeRef::StmtIf(node.ast.wrap(n)),
            Stmt::With(n) => AnyNodeRef::StmtWith(node.ast.wrap(n)),
            Stmt::Match(n) => AnyNodeRef::StmtMatch(node.ast.wrap(n)),
            Stmt::Raise(n) => AnyNodeRef::StmtRaise(node.ast.wrap(n)),
            Stmt::Try(n) => AnyNodeRef::StmtTry(node.ast.wrap(n)),
            Stmt::Assert(n) => AnyNodeRef::StmtAssert(node.ast.wrap(n)),
            Stmt::Import(n) => AnyNodeRef::StmtImport(node.ast.wrap(n)),
            Stmt::ImportFrom(n) => AnyNodeRef::StmtImportFrom(node.ast.wrap(n)),
            Stmt::Global(n) => AnyNodeRef::StmtGlobal(node.ast.wrap(n)),
            Stmt::Nonlocal(n) => AnyNodeRef::StmtNonlocal(node.ast.wrap(n)),
            Stmt::Expr(n) => AnyNodeRef::StmtExpr(node.ast.wrap(n)),
            Stmt::Pass(n) => AnyNodeRef::StmtPass(node.ast.wrap(n)),
            Stmt::Break(n) => AnyNodeRef::StmtBreak(node.ast.wrap(n)),
            Stmt::Continue(n) => AnyNodeRef::StmtContinue(node.ast.wrap(n)),
            Stmt::IpyEscapeCommand(n) => AnyNodeRef::StmtIpyEscapeCommand(node.ast.wrap(n)),
        }
    }
}

impl<'a> From<StmtRef<'a>> for AnyNodeRef<'a> {
    fn from(node: StmtRef<'a>) -> AnyNodeRef<'a> {
        match node {
            StmtRef::FunctionDef(node) => AnyNodeRef::StmtFunctionDef(node),
            StmtRef::ClassDef(node) => AnyNodeRef::StmtClassDef(node),
            StmtRef::Return(node) => AnyNodeRef::StmtReturn(node),
            StmtRef::Delete(node) => AnyNodeRef::StmtDelete(node),
            StmtRef::TypeAlias(node) => AnyNodeRef::StmtTypeAlias(node),
            StmtRef::Assign(node) => AnyNodeRef::StmtAssign(node),
            StmtRef::AugAssign(node) => AnyNodeRef::StmtAugAssign(node),
            StmtRef::AnnAssign(node) => AnyNodeRef::StmtAnnAssign(node),
            StmtRef::For(node) => AnyNodeRef::StmtFor(node),
            StmtRef::While(node) => AnyNodeRef::StmtWhile(node),
            StmtRef::If(node) => AnyNodeRef::StmtIf(node),
            StmtRef::With(node) => AnyNodeRef::StmtWith(node),
            StmtRef::Match(node) => AnyNodeRef::StmtMatch(node),
            StmtRef::Raise(node) => AnyNodeRef::StmtRaise(node),
            StmtRef::Try(node) => AnyNodeRef::StmtTry(node),
            StmtRef::Assert(node) => AnyNodeRef::StmtAssert(node),
            StmtRef::Import(node) => AnyNodeRef::StmtImport(node),
            StmtRef::ImportFrom(node) => AnyNodeRef::StmtImportFrom(node),
            StmtRef::Global(node) => AnyNodeRef::StmtGlobal(node),
            StmtRef::Nonlocal(node) => AnyNodeRef::StmtNonlocal(node),
            StmtRef::Expr(node) => AnyNodeRef::StmtExpr(node),
            StmtRef::Pass(node) => AnyNodeRef::StmtPass(node),
            StmtRef::Break(node) => AnyNodeRef::StmtBreak(node),
            StmtRef::Continue(node) => AnyNodeRef::StmtContinue(node),
            StmtRef::IpyEscapeCommand(node) => AnyNodeRef::StmtIpyEscapeCommand(node),
        }
    }
}

impl<'a> From<crate::Node<'a, &'a Expr>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a Expr>) -> AnyNodeRef<'a> {
        match node.node {
            Expr::BoolOp(n) => AnyNodeRef::ExprBoolOp(node.ast.wrap(n)),
            Expr::Named(n) => AnyNodeRef::ExprNamed(node.ast.wrap(n)),
            Expr::BinOp(n) => AnyNodeRef::ExprBinOp(node.ast.wrap(n)),
            Expr::UnaryOp(n) => AnyNodeRef::ExprUnaryOp(node.ast.wrap(n)),
            Expr::Lambda(n) => AnyNodeRef::ExprLambda(node.ast.wrap(n)),
            Expr::If(n) => AnyNodeRef::ExprIf(node.ast.wrap(n)),
            Expr::Dict(n) => AnyNodeRef::ExprDict(node.ast.wrap(n)),
            Expr::Set(n) => AnyNodeRef::ExprSet(node.ast.wrap(n)),
            Expr::ListComp(n) => AnyNodeRef::ExprListComp(node.ast.wrap(n)),
            Expr::SetComp(n) => AnyNodeRef::ExprSetComp(node.ast.wrap(n)),
            Expr::DictComp(n) => AnyNodeRef::ExprDictComp(node.ast.wrap(n)),
            Expr::Generator(n) => AnyNodeRef::ExprGenerator(node.ast.wrap(n)),
            Expr::Await(n) => AnyNodeRef::ExprAwait(node.ast.wrap(n)),
            Expr::Yield(n) => AnyNodeRef::ExprYield(node.ast.wrap(n)),
            Expr::YieldFrom(n) => AnyNodeRef::ExprYieldFrom(node.ast.wrap(n)),
            Expr::Compare(n) => AnyNodeRef::ExprCompare(node.ast.wrap(n)),
            Expr::Call(n) => AnyNodeRef::ExprCall(node.ast.wrap(n)),
            Expr::FString(n) => AnyNodeRef::ExprFString(node.ast.wrap(n)),
            Expr::StringLiteral(n) => AnyNodeRef::ExprStringLiteral(node.ast.wrap(n)),
            Expr::BytesLiteral(n) => AnyNodeRef::ExprBytesLiteral(node.ast.wrap(n)),
            Expr::NumberLiteral(n) => AnyNodeRef::ExprNumberLiteral(node.ast.wrap(n)),
            Expr::BooleanLiteral(n) => AnyNodeRef::ExprBooleanLiteral(node.ast.wrap(n)),
            Expr::NoneLiteral(n) => AnyNodeRef::ExprNoneLiteral(node.ast.wrap(n)),
            Expr::EllipsisLiteral(n) => AnyNodeRef::ExprEllipsisLiteral(node.ast.wrap(n)),
            Expr::Attribute(n) => AnyNodeRef::ExprAttribute(node.ast.wrap(n)),
            Expr::Subscript(n) => AnyNodeRef::ExprSubscript(node.ast.wrap(n)),
            Expr::Starred(n) => AnyNodeRef::ExprStarred(node.ast.wrap(n)),
            Expr::Name(n) => AnyNodeRef::ExprName(node.ast.wrap(n)),
            Expr::List(n) => AnyNodeRef::ExprList(node.ast.wrap(n)),
            Expr::Tuple(n) => AnyNodeRef::ExprTuple(node.ast.wrap(n)),
            Expr::Slice(n) => AnyNodeRef::ExprSlice(node.ast.wrap(n)),
            Expr::IpyEscapeCommand(n) => AnyNodeRef::ExprIpyEscapeCommand(node.ast.wrap(n)),
        }
    }
}

impl<'a> From<ExprRef<'a>> for AnyNodeRef<'a> {
    fn from(node: ExprRef<'a>) -> AnyNodeRef<'a> {
        match node {
            ExprRef::BoolOp(node) => AnyNodeRef::ExprBoolOp(node),
            ExprRef::Named(node) => AnyNodeRef::ExprNamed(node),
            ExprRef::BinOp(node) => AnyNodeRef::ExprBinOp(node),
            ExprRef::UnaryOp(node) => AnyNodeRef::ExprUnaryOp(node),
            ExprRef::Lambda(node) => AnyNodeRef::ExprLambda(node),
            ExprRef::If(node) => AnyNodeRef::ExprIf(node),
            ExprRef::Dict(node) => AnyNodeRef::ExprDict(node),
            ExprRef::Set(node) => AnyNodeRef::ExprSet(node),
            ExprRef::ListComp(node) => AnyNodeRef::ExprListComp(node),
            ExprRef::SetComp(node) => AnyNodeRef::ExprSetComp(node),
            ExprRef::DictComp(node) => AnyNodeRef::ExprDictComp(node),
            ExprRef::Generator(node) => AnyNodeRef::ExprGenerator(node),
            ExprRef::Await(node) => AnyNodeRef::ExprAwait(node),
            ExprRef::Yield(node) => AnyNodeRef::ExprYield(node),
            ExprRef::YieldFrom(node) => AnyNodeRef::ExprYieldFrom(node),
            ExprRef::Compare(node) => AnyNodeRef::ExprCompare(node),
            ExprRef::Call(node) => AnyNodeRef::ExprCall(node),
            ExprRef::FString(node) => AnyNodeRef::ExprFString(node),
            ExprRef::StringLiteral(node) => AnyNodeRef::ExprStringLiteral(node),
            ExprRef::BytesLiteral(node) => AnyNodeRef::ExprBytesLiteral(node),
            ExprRef::NumberLiteral(node) => AnyNodeRef::ExprNumberLiteral(node),
            ExprRef::BooleanLiteral(node) => AnyNodeRef::ExprBooleanLiteral(node),
            ExprRef::NoneLiteral(node) => AnyNodeRef::ExprNoneLiteral(node),
            ExprRef::EllipsisLiteral(node) => AnyNodeRef::ExprEllipsisLiteral(node),
            ExprRef::Attribute(node) => AnyNodeRef::ExprAttribute(node),
            ExprRef::Subscript(node) => AnyNodeRef::ExprSubscript(node),
            ExprRef::Starred(node) => AnyNodeRef::ExprStarred(node),
            ExprRef::Name(node) => AnyNodeRef::ExprName(node),
            ExprRef::List(node) => AnyNodeRef::ExprList(node),
            ExprRef::Tuple(node) => AnyNodeRef::ExprTuple(node),
            ExprRef::Slice(node) => AnyNodeRef::ExprSlice(node),
            ExprRef::IpyEscapeCommand(node) => AnyNodeRef::ExprIpyEscapeCommand(node),
        }
    }
}

impl<'a> From<crate::Node<'a, &'a ExceptHandler>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a ExceptHandler>) -> AnyNodeRef<'a> {
        match node.node {
            ExceptHandler::ExceptHandler(n) => {
                AnyNodeRef::ExceptHandlerExceptHandler(node.ast.wrap(n))
            }
        }
    }
}

impl<'a> From<ExceptHandlerRef<'a>> for AnyNodeRef<'a> {
    fn from(node: ExceptHandlerRef<'a>) -> AnyNodeRef<'a> {
        match node {
            ExceptHandlerRef::ExceptHandler(node) => AnyNodeRef::ExceptHandlerExceptHandler(node),
        }
    }
}

impl<'a> From<crate::Node<'a, &'a FStringElement>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a FStringElement>) -> AnyNodeRef<'a> {
        match node.node {
            FStringElement::Expression(n) => AnyNodeRef::FStringExpressionElement(node.ast.wrap(n)),
            FStringElement::Literal(n) => AnyNodeRef::FStringLiteralElement(node.ast.wrap(n)),
        }
    }
}

impl<'a> From<FStringElementRef<'a>> for AnyNodeRef<'a> {
    fn from(node: FStringElementRef<'a>) -> AnyNodeRef<'a> {
        match node {
            FStringElementRef::Expression(node) => AnyNodeRef::FStringExpressionElement(node),
            FStringElementRef::Literal(node) => AnyNodeRef::FStringLiteralElement(node),
        }
    }
}

impl<'a> From<crate::Node<'a, &'a Pattern>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a Pattern>) -> AnyNodeRef<'a> {
        match node.node {
            Pattern::MatchValue(n) => AnyNodeRef::PatternMatchValue(node.ast.wrap(n)),
            Pattern::MatchSingleton(n) => AnyNodeRef::PatternMatchSingleton(node.ast.wrap(n)),
            Pattern::MatchSequence(n) => AnyNodeRef::PatternMatchSequence(node.ast.wrap(n)),
            Pattern::MatchMapping(n) => AnyNodeRef::PatternMatchMapping(node.ast.wrap(n)),
            Pattern::MatchClass(n) => AnyNodeRef::PatternMatchClass(node.ast.wrap(n)),
            Pattern::MatchStar(n) => AnyNodeRef::PatternMatchStar(node.ast.wrap(n)),
            Pattern::MatchAs(n) => AnyNodeRef::PatternMatchAs(node.ast.wrap(n)),
            Pattern::MatchOr(n) => AnyNodeRef::PatternMatchOr(node.ast.wrap(n)),
        }
    }
}

impl<'a> From<PatternRef<'a>> for AnyNodeRef<'a> {
    fn from(node: PatternRef<'a>) -> AnyNodeRef<'a> {
        match node {
            PatternRef::MatchValue(node) => AnyNodeRef::PatternMatchValue(node),
            PatternRef::MatchSingleton(node) => AnyNodeRef::PatternMatchSingleton(node),
            PatternRef::MatchSequence(node) => AnyNodeRef::PatternMatchSequence(node),
            PatternRef::MatchMapping(node) => AnyNodeRef::PatternMatchMapping(node),
            PatternRef::MatchClass(node) => AnyNodeRef::PatternMatchClass(node),
            PatternRef::MatchStar(node) => AnyNodeRef::PatternMatchStar(node),
            PatternRef::MatchAs(node) => AnyNodeRef::PatternMatchAs(node),
            PatternRef::MatchOr(node) => AnyNodeRef::PatternMatchOr(node),
        }
    }
}

impl<'a> From<crate::Node<'a, &'a TypeParam>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a TypeParam>) -> AnyNodeRef<'a> {
        match node.node {
            TypeParam::TypeVar(n) => AnyNodeRef::TypeParamTypeVar(node.ast.wrap(n)),
            TypeParam::TypeVarTuple(n) => AnyNodeRef::TypeParamTypeVarTuple(node.ast.wrap(n)),
            TypeParam::ParamSpec(n) => AnyNodeRef::TypeParamParamSpec(node.ast.wrap(n)),
        }
    }
}

impl<'a> From<TypeParamRef<'a>> for AnyNodeRef<'a> {
    fn from(node: TypeParamRef<'a>) -> AnyNodeRef<'a> {
        match node {
            TypeParamRef::TypeVar(node) => AnyNodeRef::TypeParamTypeVar(node),
            TypeParamRef::TypeVarTuple(node) => AnyNodeRef::TypeParamTypeVarTuple(node),
            TypeParamRef::ParamSpec(node) => AnyNodeRef::TypeParamParamSpec(node),
        }
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ModModule>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ModModule>) -> AnyNodeRef<'a> {
        AnyNodeRef::ModModule(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ModExpression>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ModExpression>) -> AnyNodeRef<'a> {
        AnyNodeRef::ModExpression(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtFunctionDef>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtFunctionDef>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtFunctionDef(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtClassDef>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtClassDef>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtClassDef(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtReturn>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtReturn>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtReturn(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtDelete>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtDelete>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtDelete(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtTypeAlias>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtTypeAlias>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtTypeAlias(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtAssign>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtAssign>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtAssign(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtAugAssign>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtAugAssign>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtAugAssign(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtAnnAssign>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtAnnAssign>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtAnnAssign(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtFor>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtFor>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtFor(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtWhile>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtWhile>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtWhile(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtIf>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtIf>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtIf(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtWith>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtWith>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtWith(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtMatch>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtMatch>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtMatch(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtRaise>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtRaise>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtRaise(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtTry>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtTry>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtTry(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtAssert>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtAssert>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtAssert(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtImport>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtImport>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtImport(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtImportFrom>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtImportFrom>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtImportFrom(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtGlobal>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtGlobal>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtGlobal(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtNonlocal>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtNonlocal>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtNonlocal(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtExpr>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtExpr>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtExpr(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtPass>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtPass>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtPass(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtBreak>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtBreak>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtBreak(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtContinue>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtContinue>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtContinue(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StmtIpyEscapeCommand>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StmtIpyEscapeCommand>) -> AnyNodeRef<'a> {
        AnyNodeRef::StmtIpyEscapeCommand(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprBoolOp>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprBoolOp>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprBoolOp(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprNamed>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprNamed>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprNamed(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprBinOp>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprBinOp>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprBinOp(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprUnaryOp>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprUnaryOp>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprUnaryOp(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprLambda>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprLambda>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprLambda(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprIf>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprIf>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprIf(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprDict>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprDict>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprDict(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprSet>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprSet>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprSet(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprListComp>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprListComp>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprListComp(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprSetComp>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprSetComp>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprSetComp(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprDictComp>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprDictComp>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprDictComp(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprGenerator>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprGenerator>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprGenerator(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprAwait>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprAwait>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprAwait(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprYield>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprYield>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprYield(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprYieldFrom>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprYieldFrom>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprYieldFrom(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprCompare>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprCompare>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprCompare(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprCall>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprCall>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprCall(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprFString>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprFString>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprFString(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprStringLiteral>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprStringLiteral>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprStringLiteral(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprBytesLiteral>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprBytesLiteral>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprBytesLiteral(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprNumberLiteral>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprNumberLiteral>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprNumberLiteral(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprBooleanLiteral>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprBooleanLiteral>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprBooleanLiteral(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprNoneLiteral>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprNoneLiteral>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprNoneLiteral(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprEllipsisLiteral>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprEllipsisLiteral>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprEllipsisLiteral(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprAttribute>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprAttribute>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprAttribute(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprSubscript>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprSubscript>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprSubscript(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprStarred>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprStarred>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprStarred(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprName>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprName>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprName(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprList>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprList>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprList(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprTuple>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprTuple>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprTuple(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprSlice>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprSlice>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprSlice(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExprIpyEscapeCommand>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExprIpyEscapeCommand>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExprIpyEscapeCommand(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ExceptHandlerExceptHandler>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ExceptHandlerExceptHandler>) -> AnyNodeRef<'a> {
        AnyNodeRef::ExceptHandlerExceptHandler(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::FStringExpressionElement>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::FStringExpressionElement>) -> AnyNodeRef<'a> {
        AnyNodeRef::FStringExpressionElement(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::FStringLiteralElement>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::FStringLiteralElement>) -> AnyNodeRef<'a> {
        AnyNodeRef::FStringLiteralElement(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternMatchValue>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternMatchValue>) -> AnyNodeRef<'a> {
        AnyNodeRef::PatternMatchValue(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternMatchSingleton>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternMatchSingleton>) -> AnyNodeRef<'a> {
        AnyNodeRef::PatternMatchSingleton(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternMatchSequence>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternMatchSequence>) -> AnyNodeRef<'a> {
        AnyNodeRef::PatternMatchSequence(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternMatchMapping>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternMatchMapping>) -> AnyNodeRef<'a> {
        AnyNodeRef::PatternMatchMapping(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternMatchClass>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternMatchClass>) -> AnyNodeRef<'a> {
        AnyNodeRef::PatternMatchClass(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternMatchStar>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternMatchStar>) -> AnyNodeRef<'a> {
        AnyNodeRef::PatternMatchStar(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternMatchAs>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternMatchAs>) -> AnyNodeRef<'a> {
        AnyNodeRef::PatternMatchAs(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternMatchOr>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternMatchOr>) -> AnyNodeRef<'a> {
        AnyNodeRef::PatternMatchOr(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::TypeParamTypeVar>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::TypeParamTypeVar>) -> AnyNodeRef<'a> {
        AnyNodeRef::TypeParamTypeVar(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::TypeParamTypeVarTuple>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::TypeParamTypeVarTuple>) -> AnyNodeRef<'a> {
        AnyNodeRef::TypeParamTypeVarTuple(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::TypeParamParamSpec>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::TypeParamParamSpec>) -> AnyNodeRef<'a> {
        AnyNodeRef::TypeParamParamSpec(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::FStringFormatSpec>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::FStringFormatSpec>) -> AnyNodeRef<'a> {
        AnyNodeRef::FStringFormatSpec(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternArguments>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternArguments>) -> AnyNodeRef<'a> {
        AnyNodeRef::PatternArguments(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::PatternKeyword>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::PatternKeyword>) -> AnyNodeRef<'a> {
        AnyNodeRef::PatternKeyword(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::Comprehension>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::Comprehension>) -> AnyNodeRef<'a> {
        AnyNodeRef::Comprehension(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::Arguments>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::Arguments>) -> AnyNodeRef<'a> {
        AnyNodeRef::Arguments(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::Parameters>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::Parameters>) -> AnyNodeRef<'a> {
        AnyNodeRef::Parameters(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::Parameter>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::Parameter>) -> AnyNodeRef<'a> {
        AnyNodeRef::Parameter(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ParameterWithDefault>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ParameterWithDefault>) -> AnyNodeRef<'a> {
        AnyNodeRef::ParameterWithDefault(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::Keyword>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::Keyword>) -> AnyNodeRef<'a> {
        AnyNodeRef::Keyword(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::Alias>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::Alias>) -> AnyNodeRef<'a> {
        AnyNodeRef::Alias(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::WithItem>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::WithItem>) -> AnyNodeRef<'a> {
        AnyNodeRef::WithItem(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::MatchCase>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::MatchCase>) -> AnyNodeRef<'a> {
        AnyNodeRef::MatchCase(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::Decorator>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::Decorator>) -> AnyNodeRef<'a> {
        AnyNodeRef::Decorator(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::ElifElseClause>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::ElifElseClause>) -> AnyNodeRef<'a> {
        AnyNodeRef::ElifElseClause(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::TypeParams>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::TypeParams>) -> AnyNodeRef<'a> {
        AnyNodeRef::TypeParams(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::FString>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::FString>) -> AnyNodeRef<'a> {
        AnyNodeRef::FString(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::StringLiteral>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::StringLiteral>) -> AnyNodeRef<'a> {
        AnyNodeRef::StringLiteral(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::BytesLiteral>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::BytesLiteral>) -> AnyNodeRef<'a> {
        AnyNodeRef::BytesLiteral(node)
    }
}

impl<'a> From<crate::Node<'a, &'a crate::Identifier>> for AnyNodeRef<'a> {
    fn from(node: crate::Node<'a, &'a crate::Identifier>) -> AnyNodeRef<'a> {
        AnyNodeRef::Identifier(node)
    }
}

impl ruff_text_size::Ranged for AnyNodeRef<'_> {
    fn range(&self) -> ruff_text_size::TextRange {
        match self {
            AnyNodeRef::ModModule(node) => node.range(),
            AnyNodeRef::ModExpression(node) => node.range(),
            AnyNodeRef::StmtFunctionDef(node) => node.range(),
            AnyNodeRef::StmtClassDef(node) => node.range(),
            AnyNodeRef::StmtReturn(node) => node.range(),
            AnyNodeRef::StmtDelete(node) => node.range(),
            AnyNodeRef::StmtTypeAlias(node) => node.range(),
            AnyNodeRef::StmtAssign(node) => node.range(),
            AnyNodeRef::StmtAugAssign(node) => node.range(),
            AnyNodeRef::StmtAnnAssign(node) => node.range(),
            AnyNodeRef::StmtFor(node) => node.range(),
            AnyNodeRef::StmtWhile(node) => node.range(),
            AnyNodeRef::StmtIf(node) => node.range(),
            AnyNodeRef::StmtWith(node) => node.range(),
            AnyNodeRef::StmtMatch(node) => node.range(),
            AnyNodeRef::StmtRaise(node) => node.range(),
            AnyNodeRef::StmtTry(node) => node.range(),
            AnyNodeRef::StmtAssert(node) => node.range(),
            AnyNodeRef::StmtImport(node) => node.range(),
            AnyNodeRef::StmtImportFrom(node) => node.range(),
            AnyNodeRef::StmtGlobal(node) => node.range(),
            AnyNodeRef::StmtNonlocal(node) => node.range(),
            AnyNodeRef::StmtExpr(node) => node.range(),
            AnyNodeRef::StmtPass(node) => node.range(),
            AnyNodeRef::StmtBreak(node) => node.range(),
            AnyNodeRef::StmtContinue(node) => node.range(),
            AnyNodeRef::StmtIpyEscapeCommand(node) => node.range(),
            AnyNodeRef::ExprBoolOp(node) => node.range(),
            AnyNodeRef::ExprNamed(node) => node.range(),
            AnyNodeRef::ExprBinOp(node) => node.range(),
            AnyNodeRef::ExprUnaryOp(node) => node.range(),
            AnyNodeRef::ExprLambda(node) => node.range(),
            AnyNodeRef::ExprIf(node) => node.range(),
            AnyNodeRef::ExprDict(node) => node.range(),
            AnyNodeRef::ExprSet(node) => node.range(),
            AnyNodeRef::ExprListComp(node) => node.range(),
            AnyNodeRef::ExprSetComp(node) => node.range(),
            AnyNodeRef::ExprDictComp(node) => node.range(),
            AnyNodeRef::ExprGenerator(node) => node.range(),
            AnyNodeRef::ExprAwait(node) => node.range(),
            AnyNodeRef::ExprYield(node) => node.range(),
            AnyNodeRef::ExprYieldFrom(node) => node.range(),
            AnyNodeRef::ExprCompare(node) => node.range(),
            AnyNodeRef::ExprCall(node) => node.range(),
            AnyNodeRef::ExprFString(node) => node.range(),
            AnyNodeRef::ExprStringLiteral(node) => node.range(),
            AnyNodeRef::ExprBytesLiteral(node) => node.range(),
            AnyNodeRef::ExprNumberLiteral(node) => node.range(),
            AnyNodeRef::ExprBooleanLiteral(node) => node.range(),
            AnyNodeRef::ExprNoneLiteral(node) => node.range(),
            AnyNodeRef::ExprEllipsisLiteral(node) => node.range(),
            AnyNodeRef::ExprAttribute(node) => node.range(),
            AnyNodeRef::ExprSubscript(node) => node.range(),
            AnyNodeRef::ExprStarred(node) => node.range(),
            AnyNodeRef::ExprName(node) => node.range(),
            AnyNodeRef::ExprList(node) => node.range(),
            AnyNodeRef::ExprTuple(node) => node.range(),
            AnyNodeRef::ExprSlice(node) => node.range(),
            AnyNodeRef::ExprIpyEscapeCommand(node) => node.range(),
            AnyNodeRef::ExceptHandlerExceptHandler(node) => node.range(),
            AnyNodeRef::FStringExpressionElement(node) => node.range(),
            AnyNodeRef::FStringLiteralElement(node) => node.range(),
            AnyNodeRef::PatternMatchValue(node) => node.range(),
            AnyNodeRef::PatternMatchSingleton(node) => node.range(),
            AnyNodeRef::PatternMatchSequence(node) => node.range(),
            AnyNodeRef::PatternMatchMapping(node) => node.range(),
            AnyNodeRef::PatternMatchClass(node) => node.range(),
            AnyNodeRef::PatternMatchStar(node) => node.range(),
            AnyNodeRef::PatternMatchAs(node) => node.range(),
            AnyNodeRef::PatternMatchOr(node) => node.range(),
            AnyNodeRef::TypeParamTypeVar(node) => node.range(),
            AnyNodeRef::TypeParamTypeVarTuple(node) => node.range(),
            AnyNodeRef::TypeParamParamSpec(node) => node.range(),
            AnyNodeRef::FStringFormatSpec(node) => node.range(),
            AnyNodeRef::PatternArguments(node) => node.range(),
            AnyNodeRef::PatternKeyword(node) => node.range(),
            AnyNodeRef::Comprehension(node) => node.range(),
            AnyNodeRef::Arguments(node) => node.range(),
            AnyNodeRef::Parameters(node) => node.range(),
            AnyNodeRef::Parameter(node) => node.range(),
            AnyNodeRef::ParameterWithDefault(node) => node.range(),
            AnyNodeRef::Keyword(node) => node.range(),
            AnyNodeRef::Alias(node) => node.range(),
            AnyNodeRef::WithItem(node) => node.range(),
            AnyNodeRef::MatchCase(node) => node.range(),
            AnyNodeRef::Decorator(node) => node.range(),
            AnyNodeRef::ElifElseClause(node) => node.range(),
            AnyNodeRef::TypeParams(node) => node.range(),
            AnyNodeRef::FString(node) => node.range(),
            AnyNodeRef::StringLiteral(node) => node.range(),
            AnyNodeRef::BytesLiteral(node) => node.range(),
            AnyNodeRef::Identifier(node) => node.range(),
        }
    }
}

impl AnyNodeRef<'_> {
    pub fn as_ptr(&self) -> std::ptr::NonNull<()> {
        match self {
            AnyNodeRef::ModModule(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ModExpression(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtFunctionDef(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtClassDef(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtReturn(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtDelete(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtTypeAlias(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtAssign(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtAugAssign(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtAnnAssign(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtFor(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtWhile(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtIf(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtWith(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtMatch(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtRaise(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtTry(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtAssert(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtImport(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtImportFrom(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtGlobal(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtNonlocal(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtExpr(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtPass(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtBreak(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtContinue(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StmtIpyEscapeCommand(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprBoolOp(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprNamed(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprBinOp(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprUnaryOp(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprLambda(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprIf(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprDict(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprSet(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprListComp(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprSetComp(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprDictComp(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprGenerator(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprAwait(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprYield(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprYieldFrom(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprCompare(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprCall(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprFString(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprStringLiteral(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprBytesLiteral(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprNumberLiteral(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprBooleanLiteral(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprNoneLiteral(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprEllipsisLiteral(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprAttribute(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprSubscript(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprStarred(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprName(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprList(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprTuple(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprSlice(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExprIpyEscapeCommand(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ExceptHandlerExceptHandler(node) => {
                std::ptr::NonNull::from(node.as_ref()).cast()
            }
            AnyNodeRef::FStringExpressionElement(node) => {
                std::ptr::NonNull::from(node.as_ref()).cast()
            }
            AnyNodeRef::FStringLiteralElement(node) => {
                std::ptr::NonNull::from(node.as_ref()).cast()
            }
            AnyNodeRef::PatternMatchValue(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::PatternMatchSingleton(node) => {
                std::ptr::NonNull::from(node.as_ref()).cast()
            }
            AnyNodeRef::PatternMatchSequence(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::PatternMatchMapping(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::PatternMatchClass(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::PatternMatchStar(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::PatternMatchAs(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::PatternMatchOr(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::TypeParamTypeVar(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::TypeParamTypeVarTuple(node) => {
                std::ptr::NonNull::from(node.as_ref()).cast()
            }
            AnyNodeRef::TypeParamParamSpec(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::FStringFormatSpec(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::PatternArguments(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::PatternKeyword(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::Comprehension(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::Arguments(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::Parameters(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::Parameter(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ParameterWithDefault(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::Keyword(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::Alias(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::WithItem(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::MatchCase(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::Decorator(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::ElifElseClause(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::TypeParams(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::FString(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::StringLiteral(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::BytesLiteral(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
            AnyNodeRef::Identifier(node) => std::ptr::NonNull::from(node.as_ref()).cast(),
        }
    }
}

impl<'a> AnyNodeRef<'a> {
    pub fn visit_preorder<'b, V>(self, visitor: &mut V)
    where
        V: crate::visitor::source_order::SourceOrderVisitor<'b> + ?Sized,
        'a: 'b,
    {
        match self {
            AnyNodeRef::ModModule(node) => node.visit_source_order(visitor),
            AnyNodeRef::ModExpression(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtFunctionDef(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtClassDef(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtReturn(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtDelete(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtTypeAlias(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtAssign(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtAugAssign(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtAnnAssign(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtFor(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtWhile(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtIf(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtWith(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtMatch(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtRaise(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtTry(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtAssert(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtImport(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtImportFrom(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtGlobal(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtNonlocal(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtExpr(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtPass(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtBreak(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtContinue(node) => node.visit_source_order(visitor),
            AnyNodeRef::StmtIpyEscapeCommand(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprBoolOp(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprNamed(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprBinOp(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprUnaryOp(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprLambda(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprIf(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprDict(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprSet(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprListComp(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprSetComp(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprDictComp(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprGenerator(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprAwait(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprYield(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprYieldFrom(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprCompare(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprCall(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprFString(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprStringLiteral(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprBytesLiteral(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprNumberLiteral(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprBooleanLiteral(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprNoneLiteral(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprEllipsisLiteral(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprAttribute(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprSubscript(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprStarred(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprName(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprList(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprTuple(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprSlice(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExprIpyEscapeCommand(node) => node.visit_source_order(visitor),
            AnyNodeRef::ExceptHandlerExceptHandler(node) => node.visit_source_order(visitor),
            AnyNodeRef::FStringExpressionElement(node) => node.visit_source_order(visitor),
            AnyNodeRef::FStringLiteralElement(node) => node.visit_source_order(visitor),
            AnyNodeRef::PatternMatchValue(node) => node.visit_source_order(visitor),
            AnyNodeRef::PatternMatchSingleton(node) => node.visit_source_order(visitor),
            AnyNodeRef::PatternMatchSequence(node) => node.visit_source_order(visitor),
            AnyNodeRef::PatternMatchMapping(node) => node.visit_source_order(visitor),
            AnyNodeRef::PatternMatchClass(node) => node.visit_source_order(visitor),
            AnyNodeRef::PatternMatchStar(node) => node.visit_source_order(visitor),
            AnyNodeRef::PatternMatchAs(node) => node.visit_source_order(visitor),
            AnyNodeRef::PatternMatchOr(node) => node.visit_source_order(visitor),
            AnyNodeRef::TypeParamTypeVar(node) => node.visit_source_order(visitor),
            AnyNodeRef::TypeParamTypeVarTuple(node) => node.visit_source_order(visitor),
            AnyNodeRef::TypeParamParamSpec(node) => node.visit_source_order(visitor),
            AnyNodeRef::FStringFormatSpec(node) => node.visit_source_order(visitor),
            AnyNodeRef::PatternArguments(node) => node.visit_source_order(visitor),
            AnyNodeRef::PatternKeyword(node) => node.visit_source_order(visitor),
            AnyNodeRef::Comprehension(node) => node.visit_source_order(visitor),
            AnyNodeRef::Arguments(node) => node.visit_source_order(visitor),
            AnyNodeRef::Parameters(node) => node.visit_source_order(visitor),
            AnyNodeRef::Parameter(node) => node.visit_source_order(visitor),
            AnyNodeRef::ParameterWithDefault(node) => node.visit_source_order(visitor),
            AnyNodeRef::Keyword(node) => node.visit_source_order(visitor),
            AnyNodeRef::Alias(node) => node.visit_source_order(visitor),
            AnyNodeRef::WithItem(node) => node.visit_source_order(visitor),
            AnyNodeRef::MatchCase(node) => node.visit_source_order(visitor),
            AnyNodeRef::Decorator(node) => node.visit_source_order(visitor),
            AnyNodeRef::ElifElseClause(node) => node.visit_source_order(visitor),
            AnyNodeRef::TypeParams(node) => node.visit_source_order(visitor),
            AnyNodeRef::FString(node) => node.visit_source_order(visitor),
            AnyNodeRef::StringLiteral(node) => node.visit_source_order(visitor),
            AnyNodeRef::BytesLiteral(node) => node.visit_source_order(visitor),
            AnyNodeRef::Identifier(node) => node.visit_source_order(visitor),
        }
    }
}

impl AnyNodeRef<'_> {
    pub const fn is_module(self) -> bool {
        matches!(
            self,
            AnyNodeRef::ModModule(_) | AnyNodeRef::ModExpression(_)
        )
    }
}

impl AnyNodeRef<'_> {
    pub const fn is_statement(self) -> bool {
        matches!(
            self,
            AnyNodeRef::StmtFunctionDef(_)
                | AnyNodeRef::StmtClassDef(_)
                | AnyNodeRef::StmtReturn(_)
                | AnyNodeRef::StmtDelete(_)
                | AnyNodeRef::StmtTypeAlias(_)
                | AnyNodeRef::StmtAssign(_)
                | AnyNodeRef::StmtAugAssign(_)
                | AnyNodeRef::StmtAnnAssign(_)
                | AnyNodeRef::StmtFor(_)
                | AnyNodeRef::StmtWhile(_)
                | AnyNodeRef::StmtIf(_)
                | AnyNodeRef::StmtWith(_)
                | AnyNodeRef::StmtMatch(_)
                | AnyNodeRef::StmtRaise(_)
                | AnyNodeRef::StmtTry(_)
                | AnyNodeRef::StmtAssert(_)
                | AnyNodeRef::StmtImport(_)
                | AnyNodeRef::StmtImportFrom(_)
                | AnyNodeRef::StmtGlobal(_)
                | AnyNodeRef::StmtNonlocal(_)
                | AnyNodeRef::StmtExpr(_)
                | AnyNodeRef::StmtPass(_)
                | AnyNodeRef::StmtBreak(_)
                | AnyNodeRef::StmtContinue(_)
                | AnyNodeRef::StmtIpyEscapeCommand(_)
        )
    }
}

impl AnyNodeRef<'_> {
    pub const fn is_expression(self) -> bool {
        matches!(
            self,
            AnyNodeRef::ExprBoolOp(_)
                | AnyNodeRef::ExprNamed(_)
                | AnyNodeRef::ExprBinOp(_)
                | AnyNodeRef::ExprUnaryOp(_)
                | AnyNodeRef::ExprLambda(_)
                | AnyNodeRef::ExprIf(_)
                | AnyNodeRef::ExprDict(_)
                | AnyNodeRef::ExprSet(_)
                | AnyNodeRef::ExprListComp(_)
                | AnyNodeRef::ExprSetComp(_)
                | AnyNodeRef::ExprDictComp(_)
                | AnyNodeRef::ExprGenerator(_)
                | AnyNodeRef::ExprAwait(_)
                | AnyNodeRef::ExprYield(_)
                | AnyNodeRef::ExprYieldFrom(_)
                | AnyNodeRef::ExprCompare(_)
                | AnyNodeRef::ExprCall(_)
                | AnyNodeRef::ExprFString(_)
                | AnyNodeRef::ExprStringLiteral(_)
                | AnyNodeRef::ExprBytesLiteral(_)
                | AnyNodeRef::ExprNumberLiteral(_)
                | AnyNodeRef::ExprBooleanLiteral(_)
                | AnyNodeRef::ExprNoneLiteral(_)
                | AnyNodeRef::ExprEllipsisLiteral(_)
                | AnyNodeRef::ExprAttribute(_)
                | AnyNodeRef::ExprSubscript(_)
                | AnyNodeRef::ExprStarred(_)
                | AnyNodeRef::ExprName(_)
                | AnyNodeRef::ExprList(_)
                | AnyNodeRef::ExprTuple(_)
                | AnyNodeRef::ExprSlice(_)
                | AnyNodeRef::ExprIpyEscapeCommand(_)
        )
    }
}

impl AnyNodeRef<'_> {
    pub const fn is_except_handler(self) -> bool {
        matches!(self, AnyNodeRef::ExceptHandlerExceptHandler(_))
    }
}

impl AnyNodeRef<'_> {
    pub const fn is_f_string_element(self) -> bool {
        matches!(
            self,
            AnyNodeRef::FStringExpressionElement(_) | AnyNodeRef::FStringLiteralElement(_)
        )
    }
}

impl AnyNodeRef<'_> {
    pub const fn is_pattern(self) -> bool {
        matches!(
            self,
            AnyNodeRef::PatternMatchValue(_)
                | AnyNodeRef::PatternMatchSingleton(_)
                | AnyNodeRef::PatternMatchSequence(_)
                | AnyNodeRef::PatternMatchMapping(_)
                | AnyNodeRef::PatternMatchClass(_)
                | AnyNodeRef::PatternMatchStar(_)
                | AnyNodeRef::PatternMatchAs(_)
                | AnyNodeRef::PatternMatchOr(_)
        )
    }
}

impl AnyNodeRef<'_> {
    pub const fn is_type_param(self) -> bool {
        matches!(
            self,
            AnyNodeRef::TypeParamTypeVar(_)
                | AnyNodeRef::TypeParamTypeVarTuple(_)
                | AnyNodeRef::TypeParamParamSpec(_)
        )
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
pub enum NodeKind {
    ModModule,
    ModExpression,
    StmtFunctionDef,
    StmtClassDef,
    StmtReturn,
    StmtDelete,
    StmtTypeAlias,
    StmtAssign,
    StmtAugAssign,
    StmtAnnAssign,
    StmtFor,
    StmtWhile,
    StmtIf,
    StmtWith,
    StmtMatch,
    StmtRaise,
    StmtTry,
    StmtAssert,
    StmtImport,
    StmtImportFrom,
    StmtGlobal,
    StmtNonlocal,
    StmtExpr,
    StmtPass,
    StmtBreak,
    StmtContinue,
    StmtIpyEscapeCommand,
    ExprBoolOp,
    ExprNamed,
    ExprBinOp,
    ExprUnaryOp,
    ExprLambda,
    ExprIf,
    ExprDict,
    ExprSet,
    ExprListComp,
    ExprSetComp,
    ExprDictComp,
    ExprGenerator,
    ExprAwait,
    ExprYield,
    ExprYieldFrom,
    ExprCompare,
    ExprCall,
    ExprFString,
    ExprStringLiteral,
    ExprBytesLiteral,
    ExprNumberLiteral,
    ExprBooleanLiteral,
    ExprNoneLiteral,
    ExprEllipsisLiteral,
    ExprAttribute,
    ExprSubscript,
    ExprStarred,
    ExprName,
    ExprList,
    ExprTuple,
    ExprSlice,
    ExprIpyEscapeCommand,
    ExceptHandlerExceptHandler,
    FStringExpressionElement,
    FStringLiteralElement,
    PatternMatchValue,
    PatternMatchSingleton,
    PatternMatchSequence,
    PatternMatchMapping,
    PatternMatchClass,
    PatternMatchStar,
    PatternMatchAs,
    PatternMatchOr,
    TypeParamTypeVar,
    TypeParamTypeVarTuple,
    TypeParamParamSpec,
    FStringFormatSpec,
    PatternArguments,
    PatternKeyword,
    Comprehension,
    Arguments,
    Parameters,
    Parameter,
    ParameterWithDefault,
    Keyword,
    Alias,
    WithItem,
    MatchCase,
    Decorator,
    ElifElseClause,
    TypeParams,
    FString,
    StringLiteral,
    BytesLiteral,
    Identifier,
}

impl AnyNodeRef<'_> {
    pub const fn kind(self) -> NodeKind {
        match self {
            AnyNodeRef::ModModule(_) => NodeKind::ModModule,
            AnyNodeRef::ModExpression(_) => NodeKind::ModExpression,
            AnyNodeRef::StmtFunctionDef(_) => NodeKind::StmtFunctionDef,
            AnyNodeRef::StmtClassDef(_) => NodeKind::StmtClassDef,
            AnyNodeRef::StmtReturn(_) => NodeKind::StmtReturn,
            AnyNodeRef::StmtDelete(_) => NodeKind::StmtDelete,
            AnyNodeRef::StmtTypeAlias(_) => NodeKind::StmtTypeAlias,
            AnyNodeRef::StmtAssign(_) => NodeKind::StmtAssign,
            AnyNodeRef::StmtAugAssign(_) => NodeKind::StmtAugAssign,
            AnyNodeRef::StmtAnnAssign(_) => NodeKind::StmtAnnAssign,
            AnyNodeRef::StmtFor(_) => NodeKind::StmtFor,
            AnyNodeRef::StmtWhile(_) => NodeKind::StmtWhile,
            AnyNodeRef::StmtIf(_) => NodeKind::StmtIf,
            AnyNodeRef::StmtWith(_) => NodeKind::StmtWith,
            AnyNodeRef::StmtMatch(_) => NodeKind::StmtMatch,
            AnyNodeRef::StmtRaise(_) => NodeKind::StmtRaise,
            AnyNodeRef::StmtTry(_) => NodeKind::StmtTry,
            AnyNodeRef::StmtAssert(_) => NodeKind::StmtAssert,
            AnyNodeRef::StmtImport(_) => NodeKind::StmtImport,
            AnyNodeRef::StmtImportFrom(_) => NodeKind::StmtImportFrom,
            AnyNodeRef::StmtGlobal(_) => NodeKind::StmtGlobal,
            AnyNodeRef::StmtNonlocal(_) => NodeKind::StmtNonlocal,
            AnyNodeRef::StmtExpr(_) => NodeKind::StmtExpr,
            AnyNodeRef::StmtPass(_) => NodeKind::StmtPass,
            AnyNodeRef::StmtBreak(_) => NodeKind::StmtBreak,
            AnyNodeRef::StmtContinue(_) => NodeKind::StmtContinue,
            AnyNodeRef::StmtIpyEscapeCommand(_) => NodeKind::StmtIpyEscapeCommand,
            AnyNodeRef::ExprBoolOp(_) => NodeKind::ExprBoolOp,
            AnyNodeRef::ExprNamed(_) => NodeKind::ExprNamed,
            AnyNodeRef::ExprBinOp(_) => NodeKind::ExprBinOp,
            AnyNodeRef::ExprUnaryOp(_) => NodeKind::ExprUnaryOp,
            AnyNodeRef::ExprLambda(_) => NodeKind::ExprLambda,
            AnyNodeRef::ExprIf(_) => NodeKind::ExprIf,
            AnyNodeRef::ExprDict(_) => NodeKind::ExprDict,
            AnyNodeRef::ExprSet(_) => NodeKind::ExprSet,
            AnyNodeRef::ExprListComp(_) => NodeKind::ExprListComp,
            AnyNodeRef::ExprSetComp(_) => NodeKind::ExprSetComp,
            AnyNodeRef::ExprDictComp(_) => NodeKind::ExprDictComp,
            AnyNodeRef::ExprGenerator(_) => NodeKind::ExprGenerator,
            AnyNodeRef::ExprAwait(_) => NodeKind::ExprAwait,
            AnyNodeRef::ExprYield(_) => NodeKind::ExprYield,
            AnyNodeRef::ExprYieldFrom(_) => NodeKind::ExprYieldFrom,
            AnyNodeRef::ExprCompare(_) => NodeKind::ExprCompare,
            AnyNodeRef::ExprCall(_) => NodeKind::ExprCall,
            AnyNodeRef::ExprFString(_) => NodeKind::ExprFString,
            AnyNodeRef::ExprStringLiteral(_) => NodeKind::ExprStringLiteral,
            AnyNodeRef::ExprBytesLiteral(_) => NodeKind::ExprBytesLiteral,
            AnyNodeRef::ExprNumberLiteral(_) => NodeKind::ExprNumberLiteral,
            AnyNodeRef::ExprBooleanLiteral(_) => NodeKind::ExprBooleanLiteral,
            AnyNodeRef::ExprNoneLiteral(_) => NodeKind::ExprNoneLiteral,
            AnyNodeRef::ExprEllipsisLiteral(_) => NodeKind::ExprEllipsisLiteral,
            AnyNodeRef::ExprAttribute(_) => NodeKind::ExprAttribute,
            AnyNodeRef::ExprSubscript(_) => NodeKind::ExprSubscript,
            AnyNodeRef::ExprStarred(_) => NodeKind::ExprStarred,
            AnyNodeRef::ExprName(_) => NodeKind::ExprName,
            AnyNodeRef::ExprList(_) => NodeKind::ExprList,
            AnyNodeRef::ExprTuple(_) => NodeKind::ExprTuple,
            AnyNodeRef::ExprSlice(_) => NodeKind::ExprSlice,
            AnyNodeRef::ExprIpyEscapeCommand(_) => NodeKind::ExprIpyEscapeCommand,
            AnyNodeRef::ExceptHandlerExceptHandler(_) => NodeKind::ExceptHandlerExceptHandler,
            AnyNodeRef::FStringExpressionElement(_) => NodeKind::FStringExpressionElement,
            AnyNodeRef::FStringLiteralElement(_) => NodeKind::FStringLiteralElement,
            AnyNodeRef::PatternMatchValue(_) => NodeKind::PatternMatchValue,
            AnyNodeRef::PatternMatchSingleton(_) => NodeKind::PatternMatchSingleton,
            AnyNodeRef::PatternMatchSequence(_) => NodeKind::PatternMatchSequence,
            AnyNodeRef::PatternMatchMapping(_) => NodeKind::PatternMatchMapping,
            AnyNodeRef::PatternMatchClass(_) => NodeKind::PatternMatchClass,
            AnyNodeRef::PatternMatchStar(_) => NodeKind::PatternMatchStar,
            AnyNodeRef::PatternMatchAs(_) => NodeKind::PatternMatchAs,
            AnyNodeRef::PatternMatchOr(_) => NodeKind::PatternMatchOr,
            AnyNodeRef::TypeParamTypeVar(_) => NodeKind::TypeParamTypeVar,
            AnyNodeRef::TypeParamTypeVarTuple(_) => NodeKind::TypeParamTypeVarTuple,
            AnyNodeRef::TypeParamParamSpec(_) => NodeKind::TypeParamParamSpec,
            AnyNodeRef::FStringFormatSpec(_) => NodeKind::FStringFormatSpec,
            AnyNodeRef::PatternArguments(_) => NodeKind::PatternArguments,
            AnyNodeRef::PatternKeyword(_) => NodeKind::PatternKeyword,
            AnyNodeRef::Comprehension(_) => NodeKind::Comprehension,
            AnyNodeRef::Arguments(_) => NodeKind::Arguments,
            AnyNodeRef::Parameters(_) => NodeKind::Parameters,
            AnyNodeRef::Parameter(_) => NodeKind::Parameter,
            AnyNodeRef::ParameterWithDefault(_) => NodeKind::ParameterWithDefault,
            AnyNodeRef::Keyword(_) => NodeKind::Keyword,
            AnyNodeRef::Alias(_) => NodeKind::Alias,
            AnyNodeRef::WithItem(_) => NodeKind::WithItem,
            AnyNodeRef::MatchCase(_) => NodeKind::MatchCase,
            AnyNodeRef::Decorator(_) => NodeKind::Decorator,
            AnyNodeRef::ElifElseClause(_) => NodeKind::ElifElseClause,
            AnyNodeRef::TypeParams(_) => NodeKind::TypeParams,
            AnyNodeRef::FString(_) => NodeKind::FString,
            AnyNodeRef::StringLiteral(_) => NodeKind::StringLiteral,
            AnyNodeRef::BytesLiteral(_) => NodeKind::BytesLiteral,
            AnyNodeRef::Identifier(_) => NodeKind::Identifier,
        }
    }
}
